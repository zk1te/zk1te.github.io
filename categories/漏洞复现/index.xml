<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>漏洞复现 on k1te's blog</title><link>https://k1te.cn/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</link><description>Recent content in 漏洞复现 on k1te's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 12 Mar 2022 20:32:23 +0800</lastBuildDate><atom:link href="https://k1te.cn/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>Dirty_pipe复现</title><link>https://k1te.cn/2022/03/12/dirty_pipe/</link><pubDate>Sat, 12 Mar 2022 20:32:23 +0800</pubDate><guid>https://k1te.cn/2022/03/12/dirty_pipe/</guid><description>简介 攻击者通过利用此漏洞，可覆盖重写任意可读文件中的数据，从而可将普通权限的用户提升到特权 root。CVE-2022-0847 的漏洞原理类似于 CVE-2016-5195 脏牛漏洞（Dirty Cow），但它更容易被利用。漏洞作者将此漏洞命名为“Dirty Pipe”
漏洞编号：CVE-2022-0847
影响版本： Linux内核 5.8 及之后版本
环境配置 Ubuntu20.04默认内核版本是5.4：
1 2 root@ee399f8033c1:/# uname -r 5.4.0-100-generic 我们需要安装5.8及以上的内核，当然直接下载内核版本比较高的发行版也可以，比如kali。
我们可以去Index of /~kernel-ppa/mainline (ubuntu.com)找到我们需要的内核，这里选的5.16的:
下载：
1 wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.16/amd64/linux-image-unsigned-5.16.0-051600-generic_5.16.0-051600.202201092355_amd64.deb https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.16/amd64/linux-modules-5.16.0-051600-generic_5.16.0-051600.202201092355_amd64.deb 安装：
1 dpkg -i linux*.deb 更新grub系统引导并重启:
1 2 update-grub reboot POC1 第一个是作者自己发表的：The Dirty Pipe Vulnerability
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 /* SPDX-License-Identifier: GPL-2.</description></item><item><title>TP3.2.xRCE</title><link>https://k1te.cn/2021/08/14/TP_RCE/</link><pubDate>Sat, 14 Aug 2021 16:19:19 +0800</pubDate><guid>https://k1te.cn/2021/08/14/TP_RCE/</guid><description>前段时间打比赛的时候遇到了Think PHP3.2.x RCE的题目，这个洞是上个月爆出来的：【漏洞通报】ThinkPHP3.2.x RCE漏洞通报。虽然3已经不是主流版本了，但是考虑到还是有不少老的站在用，所以还是有一定的价值的，这里分析一下。
利用 这里用的是Think PHP3.2.5完整版，具体每个版本之间的区别可以看看参考链接
利用的条件是assign方法的第一个变量可控。因此我们可以在indexController写入demo：
1 2 3 4 public function index($value=&amp;#39;&amp;#39;){ $this-&amp;gt;assign($value); $this-&amp;gt;display(); } payload：?m=Home&amp;amp;c=Index&amp;amp;a=index&amp;amp;value[_filename]=.\Application\Runtime\Logs\Home\21_06_30.log
本质上是一个文件包含，再结合报错写log最终达到rce的目的
分析 这里我们先不包含log，而是包含config.ini来分析文件包含，payload：
1 ?m=Home&amp;amp;c=Index&amp;amp;a=index&amp;amp;value[_filename]=C://config.ini 首先我们的可控参数通过Controller.class.php中的assign函数最终跳到了View.class.php中的assign函数： 在该函数中将其赋值给$this-&amp;gt;tVar变量：
赋值结束后回到IndexController再进入到display函数，和上面的assign函数一样最终跳到View.class.php的display函数中，该函数中的fetch函数解析并获取模板文件内容，此时模板文件路径和内容为空：
继续跟进fetch函数，该函数中将空的templateFile传入parseTemplate函数:
当参数为空时，parseTemplate函数返回默认的模板文件位置./Application/Home/View/Index/index.html
接着往下走，系统配置的默认模板引擎为think，所以程序进入else分支
将this-&amp;gt;tVar放入params变量中跳入Hook::listen，tag变量是写死的view_parse，因此name变量为Behavior\ParseTemplateBehavior，接着进入self::exec
在exec函数中调用Behavior\ParseTemplateBehavior的run方法处理带有我们可控参数的$params变量：
在run方法中经过一些判断，最终调用fetch函数编译并加载模板文件，此时第二个参数就是我们的可控参数：array(&amp;quot;_filename&amp;quot;=&amp;gt;&amp;ldquo;C://config.ini&amp;rdquo;);
继续跟进fetch，获取缓存文件路径后，进入Storage的load方法中：
在load方法中，$_filename为之前获取的缓存文件路径，$var则为之前带有_filename=C://config.ini的数组，利用extract方法进行变量覆盖，实现任意文件包含：
众所周知，include函数不在意包含的什么文件：
因此我们可以构造一个不存在的模块，使得tp报错，此时tp会将url写入log中，所以我们可以在url中写入恶意代码，再结合上面的LFI实现任意代码执行。</description></item></channel></rss>